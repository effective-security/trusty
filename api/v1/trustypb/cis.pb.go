// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cis.proto

package trustypb

import (
	context "context"
	fmt "fmt"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"

	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Trust int32

const (
	Trust_Any     Trust = 0
	Trust_Public  Trust = 1
	Trust_Private Trust = 2
	Trust_Org     Trust = 3
)

var Trust_name = map[int32]string{
	0: "Any",
	1: "Public",
	2: "Private",
	3: "Org",
}

var Trust_value = map[string]int32{
	"Any":     0,
	"Public":  1,
	"Private": 2,
	"Org":     3,
}

func (x Trust) String() string {
	return proto.EnumName(Trust_name, int32(x))
}

func (Trust) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d9810fd17d8d9102, []int{0}
}

// Root provides X509 Root Cert information
type RootCertificate struct {
	// ID of the certificate
	ID int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// OrgID of the certificate, only used with Org scope
	OrgID int64 `protobuf:"varint,2,opt,name=org_id,json=orgId,proto3" json:"org_id,omitempty"`
	// Skid provides Subject Key Identifier
	SKID string `protobuf:"bytes,3,opt,name=skid,proto3" json:"skid,omitempty"`
	// Notbefore is the Unix time when the validity period starts
	NotBefore int64 `protobuf:"varint,4,opt,name=not_before,json=notBefore,proto3" json:"not_before,omitempty"`
	// Notafter is the Unix time when the validity period starts
	NotAfter int64 `protobuf:"varint,5,opt,name=not_after,json=notAfter,proto3" json:"not_after,omitempty"`
	// Subject name
	Subject string `protobuf:"bytes,6,opt,name=subject,proto3" json:"subject,omitempty"`
	// SHA256 thnumbprint of the cert
	Sha256 string `protobuf:"bytes,7,opt,name=sha256,proto3" json:"sha256,omitempty"`
	// Trust scope
	Trust Trust `protobuf:"varint,8,opt,name=trust,proto3,enum=trustypb.Trust" json:"trust,omitempty"`
	// PEM encoded certificate
	Pem                  string   `protobuf:"bytes,9,opt,name=pem,proto3" json:"pem,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RootCertificate) Reset()         { *m = RootCertificate{} }
func (m *RootCertificate) String() string { return proto.CompactTextString(m) }
func (*RootCertificate) ProtoMessage()    {}
func (*RootCertificate) Descriptor() ([]byte, []int) {
	return fileDescriptor_d9810fd17d8d9102, []int{0}
}
func (m *RootCertificate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RootCertificate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RootCertificate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RootCertificate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RootCertificate.Merge(m, src)
}
func (m *RootCertificate) XXX_Size() int {
	return m.Size()
}
func (m *RootCertificate) XXX_DiscardUnknown() {
	xxx_messageInfo_RootCertificate.DiscardUnknown(m)
}

var xxx_messageInfo_RootCertificate proto.InternalMessageInfo

func (m *RootCertificate) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *RootCertificate) GetOrgID() int64 {
	if m != nil {
		return m.OrgID
	}
	return 0
}

func (m *RootCertificate) GetSKID() string {
	if m != nil {
		return m.SKID
	}
	return ""
}

func (m *RootCertificate) GetNotBefore() int64 {
	if m != nil {
		return m.NotBefore
	}
	return 0
}

func (m *RootCertificate) GetNotAfter() int64 {
	if m != nil {
		return m.NotAfter
	}
	return 0
}

func (m *RootCertificate) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *RootCertificate) GetSha256() string {
	if m != nil {
		return m.Sha256
	}
	return ""
}

func (m *RootCertificate) GetTrust() Trust {
	if m != nil {
		return m.Trust
	}
	return Trust_Any
}

func (m *RootCertificate) GetPem() string {
	if m != nil {
		return m.Pem
	}
	return ""
}

// GetRootsRequest specifies root certs request
type GetRootsRequest struct {
	// OrgID of the certificate, only used with Org scope,
	// or 0 for Public or Private scope.
	OrgID                int64    `protobuf:"varint,1,opt,name=org_id,json=orgId,proto3" json:"org_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetRootsRequest) Reset()         { *m = GetRootsRequest{} }
func (m *GetRootsRequest) String() string { return proto.CompactTextString(m) }
func (*GetRootsRequest) ProtoMessage()    {}
func (*GetRootsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d9810fd17d8d9102, []int{1}
}
func (m *GetRootsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetRootsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetRootsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetRootsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRootsRequest.Merge(m, src)
}
func (m *GetRootsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetRootsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRootsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetRootsRequest proto.InternalMessageInfo

func (m *GetRootsRequest) GetOrgID() int64 {
	if m != nil {
		return m.OrgID
	}
	return 0
}

// RootsResponse provides response for GetRootsRequest
type RootsResponse struct {
	Roots                []*RootCertificate `protobuf:"bytes,1,rep,name=roots,proto3" json:"roots,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *RootsResponse) Reset()         { *m = RootsResponse{} }
func (m *RootsResponse) String() string { return proto.CompactTextString(m) }
func (*RootsResponse) ProtoMessage()    {}
func (*RootsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d9810fd17d8d9102, []int{2}
}
func (m *RootsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RootsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RootsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RootsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RootsResponse.Merge(m, src)
}
func (m *RootsResponse) XXX_Size() int {
	return m.Size()
}
func (m *RootsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RootsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RootsResponse proto.InternalMessageInfo

func (m *RootsResponse) GetRoots() []*RootCertificate {
	if m != nil {
		return m.Roots
	}
	return nil
}

// Certificate provides X509 Certificate information
type Certificate struct {
	// ID of the certificate
	ID int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// OrgID of the certificate, only used with Org scope
	OrgID int64 `protobuf:"varint,2,opt,name=org_id,json=orgId,proto3" json:"org_id,omitempty"`
	// SKID provides Subject Key Identifier
	SKID string `protobuf:"bytes,3,opt,name=skid,proto3" json:"skid,omitempty"`
	// IKID provides Issuer Key Identifier
	IKID string `protobuf:"bytes,4,opt,name=ikid,proto3" json:"ikid,omitempty"`
	// SN provides Serial Number
	SN string `protobuf:"bytes,5,opt,name=SN,proto3" json:"SN,omitempty"`
	// Notbefore is the Unix time when the validity period starts
	NotBefore int64 `protobuf:"varint,6,opt,name=not_before,json=notBefore,proto3" json:"not_before,omitempty"`
	// Notafter is the Unix time when the validity period starts
	NotAfter int64 `protobuf:"varint,7,opt,name=not_after,json=notAfter,proto3" json:"not_after,omitempty"`
	// Subject name
	Subject string `protobuf:"bytes,8,opt,name=subject,proto3" json:"subject,omitempty"`
	// Issuer name
	Issuer string `protobuf:"bytes,9,opt,name=issuer,proto3" json:"issuer,omitempty"`
	// SHA256 thnumbprint of the cert
	Sha256 string `protobuf:"bytes,10,opt,name=sha256,proto3" json:"sha256,omitempty"`
	// Profile of the certificate
	Profile string `protobuf:"bytes,11,opt,name=profile,proto3" json:"profile,omitempty"`
	// Pem encoded certificate
	Pem string `protobuf:"bytes,12,opt,name=pem,proto3" json:"pem,omitempty"`
	// IssuersPem provides PEM encoded issuers
	IssuersPem           string   `protobuf:"bytes,13,opt,name=issuers_pem,json=issuersPem,proto3" json:"issuers_pem,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Certificate) Reset()         { *m = Certificate{} }
func (m *Certificate) String() string { return proto.CompactTextString(m) }
func (*Certificate) ProtoMessage()    {}
func (*Certificate) Descriptor() ([]byte, []int) {
	return fileDescriptor_d9810fd17d8d9102, []int{3}
}
func (m *Certificate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Certificate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Certificate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Certificate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Certificate.Merge(m, src)
}
func (m *Certificate) XXX_Size() int {
	return m.Size()
}
func (m *Certificate) XXX_DiscardUnknown() {
	xxx_messageInfo_Certificate.DiscardUnknown(m)
}

var xxx_messageInfo_Certificate proto.InternalMessageInfo

func (m *Certificate) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Certificate) GetOrgID() int64 {
	if m != nil {
		return m.OrgID
	}
	return 0
}

func (m *Certificate) GetSKID() string {
	if m != nil {
		return m.SKID
	}
	return ""
}

func (m *Certificate) GetIKID() string {
	if m != nil {
		return m.IKID
	}
	return ""
}

func (m *Certificate) GetSN() string {
	if m != nil {
		return m.SN
	}
	return ""
}

func (m *Certificate) GetNotBefore() int64 {
	if m != nil {
		return m.NotBefore
	}
	return 0
}

func (m *Certificate) GetNotAfter() int64 {
	if m != nil {
		return m.NotAfter
	}
	return 0
}

func (m *Certificate) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *Certificate) GetIssuer() string {
	if m != nil {
		return m.Issuer
	}
	return ""
}

func (m *Certificate) GetSha256() string {
	if m != nil {
		return m.Sha256
	}
	return ""
}

func (m *Certificate) GetProfile() string {
	if m != nil {
		return m.Profile
	}
	return ""
}

func (m *Certificate) GetPem() string {
	if m != nil {
		return m.Pem
	}
	return ""
}

func (m *Certificate) GetIssuersPem() string {
	if m != nil {
		return m.IssuersPem
	}
	return ""
}

func init() {
	proto.RegisterEnum("trustypb.Trust", Trust_name, Trust_value)
	proto.RegisterType((*RootCertificate)(nil), "trustypb.RootCertificate")
	proto.RegisterType((*GetRootsRequest)(nil), "trustypb.GetRootsRequest")
	proto.RegisterType((*RootsResponse)(nil), "trustypb.RootsResponse")
	proto.RegisterType((*Certificate)(nil), "trustypb.Certificate")
}

func init() { proto.RegisterFile("cis.proto", fileDescriptor_d9810fd17d8d9102) }

var fileDescriptor_d9810fd17d8d9102 = []byte{
	// 579 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x93, 0xcf, 0x6e, 0xd3, 0x4c,
	0x14, 0xc5, 0x6b, 0x3b, 0x76, 0xe2, 0x9b, 0xe6, 0x4b, 0xbe, 0x11, 0x2a, 0x43, 0x55, 0xc5, 0x51,
	0x04, 0x52, 0x40, 0xa8, 0x16, 0x41, 0xc0, 0x96, 0x86, 0x4a, 0xc8, 0x42, 0x72, 0x2b, 0x87, 0x7d,
	0xe4, 0x38, 0x13, 0x33, 0xd0, 0x7a, 0xcc, 0xcc, 0xa4, 0x52, 0xb7, 0x6c, 0x59, 0xb2, 0xe1, 0x25,
	0x78, 0x8f, 0x2e, 0x91, 0xd8, 0x5b, 0xc8, 0xf0, 0x20, 0x68, 0xc6, 0x4e, 0xff, 0x84, 0x0d, 0x6c,
	0xd8, 0xdd, 0x7b, 0xce, 0xcc, 0x1d, 0xeb, 0xfe, 0x8e, 0xc1, 0x4d, 0xa8, 0xd8, 0xcf, 0x39, 0x93,
	0x0c, 0xb5, 0x24, 0x5f, 0x09, 0x79, 0x9e, 0xcf, 0x77, 0x5d, 0x9e, 0x27, 0x95, 0xb8, 0x7b, 0x2b,
	0x65, 0x29, 0xd3, 0xa5, 0xaf, 0xaa, 0x5a, 0xdd, 0x4b, 0x19, 0x4b, 0x4f, 0x88, 0x1f, 0xe7, 0xd4,
	0x8f, 0xb3, 0x8c, 0xc9, 0x58, 0x52, 0x96, 0xd5, 0x83, 0x86, 0x5f, 0x4c, 0xe8, 0x46, 0x8c, 0xc9,
	0x17, 0x84, 0x4b, 0xba, 0xa4, 0x49, 0x2c, 0x09, 0xda, 0x01, 0x93, 0x2e, 0xb0, 0x31, 0x30, 0x46,
	0xd6, 0xc4, 0x29, 0x0b, 0xcf, 0x0c, 0x0e, 0x23, 0x93, 0x2e, 0xd0, 0x00, 0x1c, 0xc6, 0xd3, 0x19,
	0x5d, 0x60, 0x53, 0x7b, 0x6e, 0x59, 0x78, 0xf6, 0x11, 0x4f, 0x83, 0xc3, 0xc8, 0x66, 0x3c, 0x0d,
	0x16, 0x68, 0x0f, 0x1a, 0xe2, 0x1d, 0x5d, 0x60, 0x6b, 0x60, 0x8c, 0xdc, 0x49, 0xab, 0x2c, 0xbc,
	0xc6, 0xf4, 0x55, 0x70, 0x18, 0x69, 0x15, 0x3d, 0x04, 0xc8, 0x98, 0x9c, 0xcd, 0xc9, 0x92, 0x71,
	0x82, 0x1b, 0x7a, 0x46, 0xa7, 0x2c, 0x3c, 0x37, 0x64, 0x72, 0xa2, 0xc5, 0xc8, 0xcd, 0xd6, 0x25,
	0xba, 0x0f, 0xaa, 0x99, 0xc5, 0x4b, 0x49, 0x38, 0xb6, 0xf5, 0xe1, 0xed, 0xb2, 0xf0, 0x5a, 0x21,
	0x93, 0x07, 0x4a, 0x8b, 0x5a, 0x59, 0x5d, 0x21, 0x0c, 0x4d, 0xb1, 0x9a, 0xbf, 0x25, 0x89, 0xc4,
	0x8e, 0x7a, 0x39, 0x5a, 0xb7, 0x68, 0x07, 0x1c, 0xf1, 0x26, 0x1e, 0x3f, 0x79, 0x8a, 0x9b, 0xda,
	0xa8, 0x3b, 0x74, 0x0f, 0x6c, 0xbd, 0x41, 0xdc, 0x1a, 0x18, 0xa3, 0xff, 0xc6, 0xdd, 0xfd, 0xf5,
	0x3e, 0xf7, 0x5f, 0xab, 0x22, 0xaa, 0x5c, 0xd4, 0x03, 0x2b, 0x27, 0xa7, 0xd8, 0xd5, 0x77, 0x55,
	0x39, 0x7c, 0x06, 0xdd, 0x97, 0x44, 0xaa, 0x8d, 0x89, 0x88, 0xbc, 0x5f, 0x11, 0x21, 0xd1, 0xdd,
	0xcb, 0xb5, 0x54, 0x2b, 0xeb, 0x5c, 0x14, 0x9e, 0xb1, 0xb9, 0x9a, 0xe1, 0x73, 0xe8, 0xd4, 0xb7,
	0x44, 0xce, 0x32, 0x41, 0x90, 0x0f, 0x36, 0x57, 0x02, 0x36, 0x06, 0xd6, 0xa8, 0x3d, 0xbe, 0x73,
	0xf5, 0x09, 0x1b, 0x3c, 0xa2, 0xea, 0xdc, 0xf0, 0xa3, 0x05, 0xed, 0x7f, 0x81, 0x69, 0x0f, 0x1a,
	0x54, 0xb9, 0x8d, 0x2b, 0x37, 0xd0, 0xae, 0x52, 0xd5, 0xab, 0xd3, 0x50, 0xf3, 0x70, 0xab, 0x57,
	0xa7, 0x61, 0x64, 0x4e, 0xc3, 0x0d, 0xb8, 0xce, 0xdf, 0xc0, 0x6d, 0xfe, 0x29, 0xdc, 0xd6, 0x6f,
	0x70, 0xa9, 0x10, 0x2b, 0xc2, 0x6b, 0x40, 0x75, 0x77, 0x0d, 0x3a, 0xdc, 0x80, 0x8e, 0xa1, 0x99,
	0x73, 0xb6, 0xa4, 0x27, 0x04, 0xb7, 0xab, 0x49, 0x75, 0xbb, 0xe6, 0xbc, 0x7d, 0xc9, 0x19, 0x79,
	0xd0, 0xae, 0xa6, 0x89, 0x99, 0x72, 0x3a, 0xda, 0x81, 0x5a, 0x3a, 0x26, 0xa7, 0x0f, 0xc6, 0x60,
	0xeb, 0xa8, 0xa0, 0x26, 0x58, 0x07, 0xd9, 0x79, 0x6f, 0x0b, 0x01, 0x38, 0xc7, 0xab, 0xf9, 0x09,
	0x4d, 0x7a, 0x06, 0x6a, 0x43, 0xf3, 0x98, 0xd3, 0xb3, 0x58, 0x92, 0x9e, 0xa9, 0x4e, 0x1c, 0xf1,
	0xb4, 0x67, 0x8d, 0x63, 0xe8, 0x2a, 0x80, 0x41, 0xb6, 0x64, 0x53, 0xc2, 0xcf, 0x68, 0x42, 0x50,
	0x08, 0xb6, 0x8e, 0x05, 0xba, 0xc6, 0x7f, 0x23, 0x60, 0xbb, 0xb7, 0x6f, 0x46, 0xe3, 0x32, 0x42,
	0xc3, 0xff, 0x3f, 0x7c, 0xfb, 0xf9, 0xc9, 0x6c, 0x23, 0xd7, 0x3f, 0x7b, 0xe4, 0xeb, 0x90, 0x4c,
	0x7a, 0x17, 0x65, 0xdf, 0xf8, 0x5a, 0xf6, 0x8d, 0xef, 0x65, 0xdf, 0xf8, 0xfc, 0xa3, 0xbf, 0x35,
	0x77, 0xf4, 0x8f, 0xfe, 0xf8, 0x57, 0x00, 0x00, 0x00, 0xff, 0xff, 0x72, 0xbc, 0x70, 0xc1, 0x3e,
	0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// CertInfoServiceClient is the client API for CertInfoService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CertInfoServiceClient interface {
	// Roots returns the root CAs
	Roots(ctx context.Context, in *GetRootsRequest, opts ...grpc.CallOption) (*RootsResponse, error)
}

type certInfoServiceClient struct {
	cc *grpc.ClientConn
}

func NewCertInfoServiceClient(cc *grpc.ClientConn) CertInfoServiceClient {
	return &certInfoServiceClient{cc}
}

func (c *certInfoServiceClient) Roots(ctx context.Context, in *GetRootsRequest, opts ...grpc.CallOption) (*RootsResponse, error) {
	out := new(RootsResponse)
	err := c.cc.Invoke(ctx, "/trustypb.CertInfoService/Roots", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CertInfoServiceServer is the server API for CertInfoService service.
type CertInfoServiceServer interface {
	// Roots returns the root CAs
	Roots(context.Context, *GetRootsRequest) (*RootsResponse, error)
}

// UnimplementedCertInfoServiceServer can be embedded to have forward compatible implementations.
type UnimplementedCertInfoServiceServer struct {
}

func (*UnimplementedCertInfoServiceServer) Roots(ctx context.Context, req *GetRootsRequest) (*RootsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Roots not implemented")
}

func RegisterCertInfoServiceServer(s *grpc.Server, srv CertInfoServiceServer) {
	s.RegisterService(&_CertInfoService_serviceDesc, srv)
}

func _CertInfoService_Roots_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRootsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertInfoServiceServer).Roots(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trustypb.CertInfoService/Roots",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertInfoServiceServer).Roots(ctx, req.(*GetRootsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _CertInfoService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "trustypb.CertInfoService",
	HandlerType: (*CertInfoServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Roots",
			Handler:    _CertInfoService_Roots_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cis.proto",
}

func (m *RootCertificate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RootCertificate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RootCertificate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Pem) > 0 {
		i -= len(m.Pem)
		copy(dAtA[i:], m.Pem)
		i = encodeVarintCis(dAtA, i, uint64(len(m.Pem)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Trust != 0 {
		i = encodeVarintCis(dAtA, i, uint64(m.Trust))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Sha256) > 0 {
		i -= len(m.Sha256)
		copy(dAtA[i:], m.Sha256)
		i = encodeVarintCis(dAtA, i, uint64(len(m.Sha256)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Subject) > 0 {
		i -= len(m.Subject)
		copy(dAtA[i:], m.Subject)
		i = encodeVarintCis(dAtA, i, uint64(len(m.Subject)))
		i--
		dAtA[i] = 0x32
	}
	if m.NotAfter != 0 {
		i = encodeVarintCis(dAtA, i, uint64(m.NotAfter))
		i--
		dAtA[i] = 0x28
	}
	if m.NotBefore != 0 {
		i = encodeVarintCis(dAtA, i, uint64(m.NotBefore))
		i--
		dAtA[i] = 0x20
	}
	if len(m.SKID) > 0 {
		i -= len(m.SKID)
		copy(dAtA[i:], m.SKID)
		i = encodeVarintCis(dAtA, i, uint64(len(m.SKID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.OrgID != 0 {
		i = encodeVarintCis(dAtA, i, uint64(m.OrgID))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintCis(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetRootsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRootsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetRootsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OrgID != 0 {
		i = encodeVarintCis(dAtA, i, uint64(m.OrgID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RootsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RootsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RootsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Roots) > 0 {
		for iNdEx := len(m.Roots) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Roots[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Certificate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Certificate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Certificate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IssuersPem) > 0 {
		i -= len(m.IssuersPem)
		copy(dAtA[i:], m.IssuersPem)
		i = encodeVarintCis(dAtA, i, uint64(len(m.IssuersPem)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Pem) > 0 {
		i -= len(m.Pem)
		copy(dAtA[i:], m.Pem)
		i = encodeVarintCis(dAtA, i, uint64(len(m.Pem)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.Profile) > 0 {
		i -= len(m.Profile)
		copy(dAtA[i:], m.Profile)
		i = encodeVarintCis(dAtA, i, uint64(len(m.Profile)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Sha256) > 0 {
		i -= len(m.Sha256)
		copy(dAtA[i:], m.Sha256)
		i = encodeVarintCis(dAtA, i, uint64(len(m.Sha256)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Issuer) > 0 {
		i -= len(m.Issuer)
		copy(dAtA[i:], m.Issuer)
		i = encodeVarintCis(dAtA, i, uint64(len(m.Issuer)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Subject) > 0 {
		i -= len(m.Subject)
		copy(dAtA[i:], m.Subject)
		i = encodeVarintCis(dAtA, i, uint64(len(m.Subject)))
		i--
		dAtA[i] = 0x42
	}
	if m.NotAfter != 0 {
		i = encodeVarintCis(dAtA, i, uint64(m.NotAfter))
		i--
		dAtA[i] = 0x38
	}
	if m.NotBefore != 0 {
		i = encodeVarintCis(dAtA, i, uint64(m.NotBefore))
		i--
		dAtA[i] = 0x30
	}
	if len(m.SN) > 0 {
		i -= len(m.SN)
		copy(dAtA[i:], m.SN)
		i = encodeVarintCis(dAtA, i, uint64(len(m.SN)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.IKID) > 0 {
		i -= len(m.IKID)
		copy(dAtA[i:], m.IKID)
		i = encodeVarintCis(dAtA, i, uint64(len(m.IKID)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SKID) > 0 {
		i -= len(m.SKID)
		copy(dAtA[i:], m.SKID)
		i = encodeVarintCis(dAtA, i, uint64(len(m.SKID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.OrgID != 0 {
		i = encodeVarintCis(dAtA, i, uint64(m.OrgID))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintCis(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintCis(dAtA []byte, offset int, v uint64) int {
	offset -= sovCis(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RootCertificate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovCis(uint64(m.ID))
	}
	if m.OrgID != 0 {
		n += 1 + sovCis(uint64(m.OrgID))
	}
	l = len(m.SKID)
	if l > 0 {
		n += 1 + l + sovCis(uint64(l))
	}
	if m.NotBefore != 0 {
		n += 1 + sovCis(uint64(m.NotBefore))
	}
	if m.NotAfter != 0 {
		n += 1 + sovCis(uint64(m.NotAfter))
	}
	l = len(m.Subject)
	if l > 0 {
		n += 1 + l + sovCis(uint64(l))
	}
	l = len(m.Sha256)
	if l > 0 {
		n += 1 + l + sovCis(uint64(l))
	}
	if m.Trust != 0 {
		n += 1 + sovCis(uint64(m.Trust))
	}
	l = len(m.Pem)
	if l > 0 {
		n += 1 + l + sovCis(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetRootsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrgID != 0 {
		n += 1 + sovCis(uint64(m.OrgID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RootsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Roots) > 0 {
		for _, e := range m.Roots {
			l = e.Size()
			n += 1 + l + sovCis(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Certificate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovCis(uint64(m.ID))
	}
	if m.OrgID != 0 {
		n += 1 + sovCis(uint64(m.OrgID))
	}
	l = len(m.SKID)
	if l > 0 {
		n += 1 + l + sovCis(uint64(l))
	}
	l = len(m.IKID)
	if l > 0 {
		n += 1 + l + sovCis(uint64(l))
	}
	l = len(m.SN)
	if l > 0 {
		n += 1 + l + sovCis(uint64(l))
	}
	if m.NotBefore != 0 {
		n += 1 + sovCis(uint64(m.NotBefore))
	}
	if m.NotAfter != 0 {
		n += 1 + sovCis(uint64(m.NotAfter))
	}
	l = len(m.Subject)
	if l > 0 {
		n += 1 + l + sovCis(uint64(l))
	}
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovCis(uint64(l))
	}
	l = len(m.Sha256)
	if l > 0 {
		n += 1 + l + sovCis(uint64(l))
	}
	l = len(m.Profile)
	if l > 0 {
		n += 1 + l + sovCis(uint64(l))
	}
	l = len(m.Pem)
	if l > 0 {
		n += 1 + l + sovCis(uint64(l))
	}
	l = len(m.IssuersPem)
	if l > 0 {
		n += 1 + l + sovCis(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovCis(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCis(x uint64) (n int) {
	return sovCis(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RootCertificate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RootCertificate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RootCertificate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgID", wireType)
			}
			m.OrgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrgID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SKID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SKID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotBefore", wireType)
			}
			m.NotBefore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NotBefore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotAfter", wireType)
			}
			m.NotAfter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NotAfter |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sha256", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sha256 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trust", wireType)
			}
			m.Trust = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Trust |= Trust(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pem", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pem = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRootsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRootsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRootsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgID", wireType)
			}
			m.OrgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrgID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RootsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RootsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RootsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roots", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roots = append(m.Roots, &RootCertificate{})
			if err := m.Roots[len(m.Roots)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Certificate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Certificate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Certificate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgID", wireType)
			}
			m.OrgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrgID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SKID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SKID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IKID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IKID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SN", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SN = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotBefore", wireType)
			}
			m.NotBefore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NotBefore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotAfter", wireType)
			}
			m.NotAfter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NotAfter |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sha256", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sha256 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Profile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pem", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pem = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IssuersPem", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IssuersPem = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCis(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCis
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCis
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCis
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCis
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCis
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCis
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCis        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCis          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCis = fmt.Errorf("proto: unexpected end of group")
)
