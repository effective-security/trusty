// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pkix.proto

package trustypb

import (
	context "context"
	fmt "fmt"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"

	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type EncodingFormat int32

const (
	EncodingFormat_PEM   EncodingFormat = 0
	EncodingFormat_DER   EncodingFormat = 1
	EncodingFormat_PKCS7 EncodingFormat = 2
)

var EncodingFormat_name = map[int32]string{
	0: "PEM",
	1: "DER",
	2: "PKCS7",
}

var EncodingFormat_value = map[string]int32{
	"PEM":   0,
	"DER":   1,
	"PKCS7": 2,
}

func (x EncodingFormat) String() string {
	return proto.EnumName(EncodingFormat_name, int32(x))
}

func (EncodingFormat) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b687f69c61c1b2df, []int{0}
}

// X509Name specifies X509 Name
type X509Name struct {
	Country              string   `protobuf:"bytes,1,opt,name=country,proto3" json:"country,omitempty"`
	State                string   `protobuf:"bytes,2,opt,name=state,proto3" json:"state,omitempty"`
	Locality             string   `protobuf:"bytes,3,opt,name=locality,proto3" json:"locality,omitempty"`
	Organisation         string   `protobuf:"bytes,4,opt,name=organisation,proto3" json:"organisation,omitempty"`
	OrganisationalUnit   string   `protobuf:"bytes,5,opt,name=organisational_unit,json=organisationalUnit,proto3" json:"organisational_unit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *X509Name) Reset()         { *m = X509Name{} }
func (m *X509Name) String() string { return proto.CompactTextString(m) }
func (*X509Name) ProtoMessage()    {}
func (*X509Name) Descriptor() ([]byte, []int) {
	return fileDescriptor_b687f69c61c1b2df, []int{0}
}
func (m *X509Name) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *X509Name) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_X509Name.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *X509Name) XXX_Merge(src proto.Message) {
	xxx_messageInfo_X509Name.Merge(m, src)
}
func (m *X509Name) XXX_Size() int {
	return m.Size()
}
func (m *X509Name) XXX_DiscardUnknown() {
	xxx_messageInfo_X509Name.DiscardUnknown(m)
}

var xxx_messageInfo_X509Name proto.InternalMessageInfo

func (m *X509Name) GetCountry() string {
	if m != nil {
		return m.Country
	}
	return ""
}

func (m *X509Name) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *X509Name) GetLocality() string {
	if m != nil {
		return m.Locality
	}
	return ""
}

func (m *X509Name) GetOrganisation() string {
	if m != nil {
		return m.Organisation
	}
	return ""
}

func (m *X509Name) GetOrganisationalUnit() string {
	if m != nil {
		return m.OrganisationalUnit
	}
	return ""
}

// X509Subject specifies X509 Subject
type X509Subject struct {
	Cn                   string      `protobuf:"bytes,1,opt,name=cn,proto3" json:"cn,omitempty"`
	Names                []*X509Name `protobuf:"bytes,2,rep,name=names,proto3" json:"names,omitempty"`
	SerialNumber         string      `protobuf:"bytes,3,opt,name=serial_number,json=serialNumber,proto3" json:"serial_number,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *X509Subject) Reset()         { *m = X509Subject{} }
func (m *X509Subject) String() string { return proto.CompactTextString(m) }
func (*X509Subject) ProtoMessage()    {}
func (*X509Subject) Descriptor() ([]byte, []int) {
	return fileDescriptor_b687f69c61c1b2df, []int{1}
}
func (m *X509Subject) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *X509Subject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_X509Subject.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *X509Subject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_X509Subject.Merge(m, src)
}
func (m *X509Subject) XXX_Size() int {
	return m.Size()
}
func (m *X509Subject) XXX_DiscardUnknown() {
	xxx_messageInfo_X509Subject.DiscardUnknown(m)
}

var xxx_messageInfo_X509Subject proto.InternalMessageInfo

func (m *X509Subject) GetCn() string {
	if m != nil {
		return m.Cn
	}
	return ""
}

func (m *X509Subject) GetNames() []*X509Name {
	if m != nil {
		return m.Names
	}
	return nil
}

func (m *X509Subject) GetSerialNumber() string {
	if m != nil {
		return m.SerialNumber
	}
	return ""
}

type CertProfileInfoRequest struct {
	Label                string   `protobuf:"bytes,1,opt,name=label,proto3" json:"label,omitempty"`
	Profile              string   `protobuf:"bytes,2,opt,name=profile,proto3" json:"profile,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CertProfileInfoRequest) Reset()         { *m = CertProfileInfoRequest{} }
func (m *CertProfileInfoRequest) String() string { return proto.CompactTextString(m) }
func (*CertProfileInfoRequest) ProtoMessage()    {}
func (*CertProfileInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b687f69c61c1b2df, []int{2}
}
func (m *CertProfileInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CertProfileInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CertProfileInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CertProfileInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertProfileInfoRequest.Merge(m, src)
}
func (m *CertProfileInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *CertProfileInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CertProfileInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CertProfileInfoRequest proto.InternalMessageInfo

func (m *CertProfileInfoRequest) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *CertProfileInfoRequest) GetProfile() string {
	if m != nil {
		return m.Profile
	}
	return ""
}

// CAConstraint specifies various CA constraints on the signed certificate.
// CAConstraint would verify against (and override) the CA
// extensions in the given CSR.
type CAConstraint struct {
	IsCa                 bool     `protobuf:"varint,1,opt,name=is_ca,json=isCa,proto3" json:"is_ca,omitempty"`
	MaxPathLen           int32    `protobuf:"varint,2,opt,name=max_path_len,json=maxPathLen,proto3" json:"max_path_len,omitempty"`
	MaxPathLenZero       int32    `protobuf:"varint,3,opt,name=max_path_len_zero,json=maxPathLenZero,proto3" json:"max_path_len_zero,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CAConstraint) Reset()         { *m = CAConstraint{} }
func (m *CAConstraint) String() string { return proto.CompactTextString(m) }
func (*CAConstraint) ProtoMessage()    {}
func (*CAConstraint) Descriptor() ([]byte, []int) {
	return fileDescriptor_b687f69c61c1b2df, []int{3}
}
func (m *CAConstraint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CAConstraint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CAConstraint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CAConstraint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CAConstraint.Merge(m, src)
}
func (m *CAConstraint) XXX_Size() int {
	return m.Size()
}
func (m *CAConstraint) XXX_DiscardUnknown() {
	xxx_messageInfo_CAConstraint.DiscardUnknown(m)
}

var xxx_messageInfo_CAConstraint proto.InternalMessageInfo

func (m *CAConstraint) GetIsCa() bool {
	if m != nil {
		return m.IsCa
	}
	return false
}

func (m *CAConstraint) GetMaxPathLen() int32 {
	if m != nil {
		return m.MaxPathLen
	}
	return 0
}

func (m *CAConstraint) GetMaxPathLenZero() int32 {
	if m != nil {
		return m.MaxPathLenZero
	}
	return 0
}

type CSRAllowedFields struct {
	Subject              bool     `protobuf:"varint,1,opt,name=subject,proto3" json:"subject,omitempty"`
	Dns                  bool     `protobuf:"varint,2,opt,name=dns,proto3" json:"dns,omitempty"`
	Ip                   bool     `protobuf:"varint,3,opt,name=ip,proto3" json:"ip,omitempty"`
	Email                bool     `protobuf:"varint,4,opt,name=email,proto3" json:"email,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CSRAllowedFields) Reset()         { *m = CSRAllowedFields{} }
func (m *CSRAllowedFields) String() string { return proto.CompactTextString(m) }
func (*CSRAllowedFields) ProtoMessage()    {}
func (*CSRAllowedFields) Descriptor() ([]byte, []int) {
	return fileDescriptor_b687f69c61c1b2df, []int{4}
}
func (m *CSRAllowedFields) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSRAllowedFields) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CSRAllowedFields.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CSRAllowedFields) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSRAllowedFields.Merge(m, src)
}
func (m *CSRAllowedFields) XXX_Size() int {
	return m.Size()
}
func (m *CSRAllowedFields) XXX_DiscardUnknown() {
	xxx_messageInfo_CSRAllowedFields.DiscardUnknown(m)
}

var xxx_messageInfo_CSRAllowedFields proto.InternalMessageInfo

func (m *CSRAllowedFields) GetSubject() bool {
	if m != nil {
		return m.Subject
	}
	return false
}

func (m *CSRAllowedFields) GetDns() bool {
	if m != nil {
		return m.Dns
	}
	return false
}

func (m *CSRAllowedFields) GetIp() bool {
	if m != nil {
		return m.Ip
	}
	return false
}

func (m *CSRAllowedFields) GetEmail() bool {
	if m != nil {
		return m.Email
	}
	return false
}

// CertProfile provides certificate profile
type CertProfile struct {
	Description string `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	// Usage provides a list key usages
	Usages            []string      `protobuf:"bytes,2,rep,name=usages,proto3" json:"usages,omitempty"`
	CAConstraint      *CAConstraint `protobuf:"bytes,3,opt,name=ca_constraint,json=caConstraint,proto3" json:"ca_constraint,omitempty"`
	OCSPNoCheck       bool          `protobuf:"varint,4,opt,name=ocsp_no_check,json=ocspNoCheck,proto3" json:"ocsp_no_check,omitempty"`
	Expiry            string        `protobuf:"bytes,5,opt,name=expiry,proto3" json:"expiry,omitempty"`
	Backdate          string        `protobuf:"bytes,6,opt,name=backdate,proto3" json:"backdate,omitempty"`
	AllowedExtensions []string      `protobuf:"bytes,7,rep,name=allowed_extensions,json=allowedExtensions,proto3" json:"allowed_extensions,omitempty"`
	// AllowedCommonNames specifies a RegExp to check for allowed names.
	// If not provided, then all names are allowed
	AllowedCommonNames string `protobuf:"bytes,8,opt,name=allowed_names,json=allowedNames,proto3" json:"allowed_names,omitempty"`
	// AllowedDNS specifies a RegExp to check for allowed DNS.
	// If not provided, then all names are allowed
	AllowedDns string `protobuf:"bytes,9,opt,name=allowed_dns,json=allowedDns,proto3" json:"allowed_dns,omitempty"`
	// AllowedEmail specifies a RegExp to check for allowed email.
	// If not provided, then all names are allowed
	AllowedEmail string `protobuf:"bytes,10,opt,name=allowed_email,json=allowedEmail,proto3" json:"allowed_email,omitempty"`
	// AllowedFields provides booleans for fields in the CSR.
	// If a AllowedFields is not present in a CertProfile,
	// all of these fields may be copied from the CSR into the signed certificate.
	// If a AllowedFields *is* present in a CertProfile,
	// only those fields with a `true` value in the AllowedFields may
	// be copied from the CSR to the signed certificate.
	// Note that some of these fields, like Subject, can be provided or
	// partially provided through the API.
	// Since API clients are expected to be trusted, but CSRs are not, fields
	// provided through the API are not subject to validation through this
	// mechanism.
	AllowedFields        *CSRAllowedFields `protobuf:"bytes,11,opt,name=allowed_fields,json=allowedFields,proto3" json:"allowed_fields,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *CertProfile) Reset()         { *m = CertProfile{} }
func (m *CertProfile) String() string { return proto.CompactTextString(m) }
func (*CertProfile) ProtoMessage()    {}
func (*CertProfile) Descriptor() ([]byte, []int) {
	return fileDescriptor_b687f69c61c1b2df, []int{5}
}
func (m *CertProfile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CertProfile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CertProfile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CertProfile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertProfile.Merge(m, src)
}
func (m *CertProfile) XXX_Size() int {
	return m.Size()
}
func (m *CertProfile) XXX_DiscardUnknown() {
	xxx_messageInfo_CertProfile.DiscardUnknown(m)
}

var xxx_messageInfo_CertProfile proto.InternalMessageInfo

func (m *CertProfile) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *CertProfile) GetUsages() []string {
	if m != nil {
		return m.Usages
	}
	return nil
}

func (m *CertProfile) GetCAConstraint() *CAConstraint {
	if m != nil {
		return m.CAConstraint
	}
	return nil
}

func (m *CertProfile) GetOCSPNoCheck() bool {
	if m != nil {
		return m.OCSPNoCheck
	}
	return false
}

func (m *CertProfile) GetExpiry() string {
	if m != nil {
		return m.Expiry
	}
	return ""
}

func (m *CertProfile) GetBackdate() string {
	if m != nil {
		return m.Backdate
	}
	return ""
}

func (m *CertProfile) GetAllowedExtensions() []string {
	if m != nil {
		return m.AllowedExtensions
	}
	return nil
}

func (m *CertProfile) GetAllowedCommonNames() string {
	if m != nil {
		return m.AllowedCommonNames
	}
	return ""
}

func (m *CertProfile) GetAllowedDns() string {
	if m != nil {
		return m.AllowedDns
	}
	return ""
}

func (m *CertProfile) GetAllowedEmail() string {
	if m != nil {
		return m.AllowedEmail
	}
	return ""
}

func (m *CertProfile) GetAllowedFields() *CSRAllowedFields {
	if m != nil {
		return m.AllowedFields
	}
	return nil
}

// CertProfileInfo is the response for an Profile Info API request
type CertProfileInfo struct {
	Issuer               string       `protobuf:"bytes,1,opt,name=issuer,proto3" json:"issuer,omitempty"`
	Profile              *CertProfile `protobuf:"bytes,3,opt,name=profile,proto3" json:"profile,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *CertProfileInfo) Reset()         { *m = CertProfileInfo{} }
func (m *CertProfileInfo) String() string { return proto.CompactTextString(m) }
func (*CertProfileInfo) ProtoMessage()    {}
func (*CertProfileInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_b687f69c61c1b2df, []int{6}
}
func (m *CertProfileInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CertProfileInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CertProfileInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CertProfileInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertProfileInfo.Merge(m, src)
}
func (m *CertProfileInfo) XXX_Size() int {
	return m.Size()
}
func (m *CertProfileInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CertProfileInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CertProfileInfo proto.InternalMessageInfo

func (m *CertProfileInfo) GetIssuer() string {
	if m != nil {
		return m.Issuer
	}
	return ""
}

func (m *CertProfileInfo) GetProfile() *CertProfile {
	if m != nil {
		return m.Profile
	}
	return nil
}

// CertificateBundle provides certificate and its issuers
type CertificateBundle struct {
	// Certificate provides the certificate in PEM format
	Certificate string `protobuf:"bytes,1,opt,name=certificate,proto3" json:"certificate,omitempty"`
	// Intermediates provides the intermediate CA certificates bundle in PEM format
	Intermediates string `protobuf:"bytes,2,opt,name=intermediates,proto3" json:"intermediates,omitempty"`
	// Root provides the Root CA certifica in PEM format
	Root                 string   `protobuf:"bytes,3,opt,name=root,proto3" json:"root,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CertificateBundle) Reset()         { *m = CertificateBundle{} }
func (m *CertificateBundle) String() string { return proto.CompactTextString(m) }
func (*CertificateBundle) ProtoMessage()    {}
func (*CertificateBundle) Descriptor() ([]byte, []int) {
	return fileDescriptor_b687f69c61c1b2df, []int{7}
}
func (m *CertificateBundle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CertificateBundle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CertificateBundle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CertificateBundle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertificateBundle.Merge(m, src)
}
func (m *CertificateBundle) XXX_Size() int {
	return m.Size()
}
func (m *CertificateBundle) XXX_DiscardUnknown() {
	xxx_messageInfo_CertificateBundle.DiscardUnknown(m)
}

var xxx_messageInfo_CertificateBundle proto.InternalMessageInfo

func (m *CertificateBundle) GetCertificate() string {
	if m != nil {
		return m.Certificate
	}
	return ""
}

func (m *CertificateBundle) GetIntermediates() string {
	if m != nil {
		return m.Intermediates
	}
	return ""
}

func (m *CertificateBundle) GetRoot() string {
	if m != nil {
		return m.Root
	}
	return ""
}

// IssuerInfo provides Issuer information
type IssuerInfo struct {
	// Certificate provides the certificate in PEM format
	Certificate string `protobuf:"bytes,1,opt,name=certificate,proto3" json:"certificate,omitempty"`
	// Intermediates provides the intermediate CA certificates bundle in PEM format
	Intermediates string `protobuf:"bytes,2,opt,name=intermediates,proto3" json:"intermediates,omitempty"`
	// Root provides the Root CA certificate in PEM format
	Root string `protobuf:"bytes,3,opt,name=root,proto3" json:"root,omitempty"`
	// Label specifies the Issuer's label
	Label                string   `protobuf:"bytes,4,opt,name=label,proto3" json:"label,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IssuerInfo) Reset()         { *m = IssuerInfo{} }
func (m *IssuerInfo) String() string { return proto.CompactTextString(m) }
func (*IssuerInfo) ProtoMessage()    {}
func (*IssuerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_b687f69c61c1b2df, []int{8}
}
func (m *IssuerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IssuerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IssuerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IssuerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IssuerInfo.Merge(m, src)
}
func (m *IssuerInfo) XXX_Size() int {
	return m.Size()
}
func (m *IssuerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_IssuerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_IssuerInfo proto.InternalMessageInfo

func (m *IssuerInfo) GetCertificate() string {
	if m != nil {
		return m.Certificate
	}
	return ""
}

func (m *IssuerInfo) GetIntermediates() string {
	if m != nil {
		return m.Intermediates
	}
	return ""
}

func (m *IssuerInfo) GetRoot() string {
	if m != nil {
		return m.Root
	}
	return ""
}

func (m *IssuerInfo) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

// IssuersInfoResponse provides response for Issuers Info request
type IssuersInfoResponse struct {
	Issuers              []*IssuerInfo `protobuf:"bytes,1,rep,name=issuers,proto3" json:"issuers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *IssuersInfoResponse) Reset()         { *m = IssuersInfoResponse{} }
func (m *IssuersInfoResponse) String() string { return proto.CompactTextString(m) }
func (*IssuersInfoResponse) ProtoMessage()    {}
func (*IssuersInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b687f69c61c1b2df, []int{9}
}
func (m *IssuersInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IssuersInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IssuersInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IssuersInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IssuersInfoResponse.Merge(m, src)
}
func (m *IssuersInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *IssuersInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_IssuersInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_IssuersInfoResponse proto.InternalMessageInfo

func (m *IssuersInfoResponse) GetIssuers() []*IssuerInfo {
	if m != nil {
		return m.Issuers
	}
	return nil
}

// CreateCertificateRequest specifies certificate request
type CreateCertificateRequest struct {
	// RequestFormat provides the certificate request format: CSR, CMS
	RequestFormat EncodingFormat `protobuf:"varint,1,opt,name=request_format,json=requestFormat,proto3,enum=trustypb.EncodingFormat" json:"request_format,omitempty"`
	// Request provides the certificate request
	Request string `protobuf:"bytes,2,opt,name=request,proto3" json:"request,omitempty"`
	// Profile specifies the certificate profile: client, server, spiffe
	Profile string `protobuf:"bytes,3,opt,name=profile,proto3" json:"profile,omitempty"`
	// IssuerLabel specifies which Issuer to be appointed to sign the request
	IssuerLabel string `protobuf:"bytes,4,opt,name=issuer_label,json=issuerLabel,proto3" json:"issuer_label,omitempty"`
	// WithBundle specifies whether to include an "optimal" certificate bundle along with the certificate
	WithBundle bool `protobuf:"varint,5,opt,name=with_bundle,json=withBundle,proto3" json:"with_bundle,omitempty"`
	// Token provides the authorization token for the request
	Token                string   `protobuf:"bytes,6,opt,name=token,proto3" json:"token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateCertificateRequest) Reset()         { *m = CreateCertificateRequest{} }
func (m *CreateCertificateRequest) String() string { return proto.CompactTextString(m) }
func (*CreateCertificateRequest) ProtoMessage()    {}
func (*CreateCertificateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b687f69c61c1b2df, []int{10}
}
func (m *CreateCertificateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateCertificateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateCertificateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateCertificateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateCertificateRequest.Merge(m, src)
}
func (m *CreateCertificateRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateCertificateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateCertificateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateCertificateRequest proto.InternalMessageInfo

func (m *CreateCertificateRequest) GetRequestFormat() EncodingFormat {
	if m != nil {
		return m.RequestFormat
	}
	return EncodingFormat_PEM
}

func (m *CreateCertificateRequest) GetRequest() string {
	if m != nil {
		return m.Request
	}
	return ""
}

func (m *CreateCertificateRequest) GetProfile() string {
	if m != nil {
		return m.Profile
	}
	return ""
}

func (m *CreateCertificateRequest) GetIssuerLabel() string {
	if m != nil {
		return m.IssuerLabel
	}
	return ""
}

func (m *CreateCertificateRequest) GetWithBundle() bool {
	if m != nil {
		return m.WithBundle
	}
	return false
}

func (m *CreateCertificateRequest) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func init() {
	proto.RegisterEnum("trustypb.EncodingFormat", EncodingFormat_name, EncodingFormat_value)
	proto.RegisterType((*X509Name)(nil), "trustypb.X509Name")
	proto.RegisterType((*X509Subject)(nil), "trustypb.X509Subject")
	proto.RegisterType((*CertProfileInfoRequest)(nil), "trustypb.CertProfileInfoRequest")
	proto.RegisterType((*CAConstraint)(nil), "trustypb.CAConstraint")
	proto.RegisterType((*CSRAllowedFields)(nil), "trustypb.CSRAllowedFields")
	proto.RegisterType((*CertProfile)(nil), "trustypb.CertProfile")
	proto.RegisterType((*CertProfileInfo)(nil), "trustypb.CertProfileInfo")
	proto.RegisterType((*CertificateBundle)(nil), "trustypb.CertificateBundle")
	proto.RegisterType((*IssuerInfo)(nil), "trustypb.IssuerInfo")
	proto.RegisterType((*IssuersInfoResponse)(nil), "trustypb.IssuersInfoResponse")
	proto.RegisterType((*CreateCertificateRequest)(nil), "trustypb.CreateCertificateRequest")
}

func init() { proto.RegisterFile("pkix.proto", fileDescriptor_b687f69c61c1b2df) }

var fileDescriptor_b687f69c61c1b2df = []byte{
	// 1054 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0xcf, 0x6e, 0x23, 0xc5,
	0x13, 0x5e, 0xdb, 0x71, 0xe2, 0xd4, 0xd8, 0x5e, 0xa7, 0x93, 0x5f, 0x7e, 0x13, 0x03, 0x71, 0x18,
	0x38, 0x04, 0xa4, 0x8d, 0x21, 0x2b, 0x84, 0x10, 0x07, 0x94, 0x78, 0xbd, 0x62, 0xc5, 0x6e, 0x88,
	0x26, 0x42, 0x5a, 0xed, 0x65, 0xd4, 0x6e, 0x77, 0x9c, 0x26, 0x33, 0xdd, 0x43, 0x77, 0x7b, 0xd7,
	0xe6, 0xc0, 0x81, 0x57, 0xe0, 0xc2, 0x3b, 0xf0, 0x22, 0x88, 0x13, 0x12, 0xf7, 0x08, 0x19, 0x2e,
	0xdc, 0x79, 0x00, 0xd4, 0x7f, 0x26, 0x1e, 0x47, 0xec, 0x91, 0x5b, 0x7f, 0x5f, 0x97, 0xab, 0x6a,
	0xbe, 0xfa, 0xba, 0x64, 0x80, 0xfc, 0x9a, 0xcd, 0x8e, 0x72, 0x29, 0xb4, 0x40, 0x0d, 0x2d, 0xa7,
	0x4a, 0xcf, 0xf3, 0x51, 0x77, 0x53, 0xe6, 0xc4, 0x91, 0xdd, 0x9d, 0x89, 0x98, 0x08, 0x7b, 0xec,
	0x9b, 0x93, 0x67, 0xdf, 0x9c, 0x08, 0x31, 0x49, 0x69, 0x1f, 0xe7, 0xac, 0x8f, 0x39, 0x17, 0x1a,
	0x6b, 0x26, 0xb8, 0x72, 0xb7, 0xd1, 0x4f, 0x15, 0x68, 0x3c, 0xff, 0xe8, 0x83, 0x4f, 0xce, 0x70,
	0x46, 0x51, 0x08, 0x1b, 0x44, 0x4c, 0xb9, 0x96, 0xf3, 0xb0, 0x72, 0x50, 0x39, 0xdc, 0x8c, 0x0b,
	0x88, 0x76, 0xa0, 0xae, 0x34, 0xd6, 0x34, 0xac, 0x5a, 0xde, 0x01, 0xd4, 0x85, 0x46, 0x2a, 0x08,
	0x4e, 0x99, 0x9e, 0x87, 0x35, 0x7b, 0x71, 0x8b, 0x51, 0x04, 0x4d, 0x21, 0x27, 0x98, 0x33, 0x65,
	0xeb, 0x85, 0x6b, 0xf6, 0x7e, 0x85, 0x43, 0x7d, 0xd8, 0x2e, 0x63, 0x9c, 0x26, 0x53, 0xce, 0x74,
	0x58, 0xb7, 0xa1, 0x68, 0xf5, 0xea, 0x2b, 0xce, 0x74, 0x94, 0x42, 0x60, 0x9a, 0xbd, 0x98, 0x8e,
	0xbe, 0xa6, 0x44, 0xa3, 0x36, 0x54, 0x09, 0xf7, 0xad, 0x56, 0x09, 0x47, 0x87, 0x50, 0xe7, 0x38,
	0xa3, 0x2a, 0xac, 0x1e, 0xd4, 0x0e, 0x83, 0x63, 0x74, 0x54, 0xa8, 0x74, 0x54, 0x7c, 0x62, 0xec,
	0x02, 0xd0, 0x3b, 0xd0, 0x52, 0x54, 0x32, 0x9c, 0x26, 0x7c, 0x9a, 0x8d, 0xa8, 0xf4, 0xed, 0x37,
	0x1d, 0x79, 0x66, 0xb9, 0xe8, 0x73, 0xd8, 0x1d, 0x50, 0xa9, 0xcf, 0xa5, 0xb8, 0x64, 0x29, 0x7d,
	0xc2, 0x2f, 0x45, 0x4c, 0xbf, 0x99, 0x52, 0xa5, 0x8d, 0x1c, 0x29, 0x1e, 0xd1, 0xd4, 0xd7, 0x76,
	0xc0, 0xc8, 0x97, 0xbb, 0x58, 0x2f, 0x53, 0x01, 0xa3, 0x1c, 0x9a, 0x83, 0x93, 0x81, 0xe0, 0x4a,
	0x4b, 0xcc, 0xb8, 0x46, 0xdb, 0x50, 0x67, 0x2a, 0x21, 0xd8, 0xfe, 0xbe, 0x11, 0xaf, 0x31, 0x35,
	0xc0, 0xe8, 0x00, 0x9a, 0x19, 0x9e, 0x25, 0x39, 0xd6, 0x57, 0x49, 0x4a, 0xb9, 0xcd, 0x51, 0x8f,
	0x21, 0xc3, 0xb3, 0x73, 0xac, 0xaf, 0x9e, 0x52, 0x8e, 0xde, 0x83, 0xad, 0x72, 0x44, 0xf2, 0x2d,
	0x95, 0xc2, 0x76, 0x5e, 0x8f, 0xdb, 0xcb, 0xb0, 0x17, 0x54, 0x8a, 0x68, 0x0c, 0x9d, 0xc1, 0x45,
	0x7c, 0x92, 0xa6, 0xe2, 0x15, 0x1d, 0x3f, 0x66, 0x34, 0x1d, 0x2b, 0xd3, 0x9f, 0x72, 0xca, 0xf9,
	0xba, 0x05, 0x44, 0x1d, 0xa8, 0x8d, 0xb9, 0xb2, 0x15, 0x1b, 0xb1, 0x39, 0x1a, 0x69, 0x59, 0x6e,
	0x73, 0x37, 0xe2, 0x2a, 0xcb, 0xcd, 0x17, 0xd3, 0x0c, 0xb3, 0xd4, 0xce, 0xb1, 0x11, 0x3b, 0x10,
	0xfd, 0x5d, 0x83, 0xa0, 0x24, 0x11, 0x3a, 0x80, 0x60, 0x4c, 0x15, 0x91, 0x2c, 0xb7, 0x33, 0x77,
	0xea, 0x94, 0x29, 0xb4, 0x0b, 0xeb, 0x53, 0x85, 0x27, 0x7e, 0x46, 0x9b, 0xb1, 0x47, 0xe8, 0x19,
	0xb4, 0x08, 0x4e, 0xc8, 0xad, 0x44, 0xb6, 0x74, 0x70, 0xbc, 0xbb, 0x1c, 0x61, 0x59, 0xc0, 0xd3,
	0xce, 0xe2, 0xa6, 0xb7, 0x22, 0x69, 0xdc, 0x24, 0xb8, 0x24, 0xf0, 0x43, 0x68, 0x09, 0xa2, 0xf2,
	0x84, 0x8b, 0x84, 0x5c, 0x51, 0x72, 0xed, 0xda, 0x3e, 0xbd, 0xbf, 0xb8, 0xe9, 0x05, 0x5f, 0x0e,
	0x2e, 0xce, 0xcf, 0xc4, 0xc0, 0xd0, 0x71, 0x60, 0xa2, 0x3c, 0x30, 0xbd, 0xd1, 0x59, 0xce, 0xe4,
	0xdc, 0x3b, 0xd0, 0x23, 0x63, 0xf3, 0x11, 0x26, 0xd7, 0x63, 0xe3, 0xff, 0x75, 0x67, 0xf3, 0x02,
	0xa3, 0x07, 0x80, 0xb0, 0x13, 0x39, 0xa1, 0x33, 0x4d, 0xb9, 0x32, 0x6f, 0x2b, 0xdc, 0xb0, 0xdf,
	0xb6, 0xe5, 0x6f, 0x86, 0xb7, 0x17, 0xe8, 0x53, 0x68, 0x15, 0xe1, 0xce, 0xa9, 0x0d, 0x93, 0xef,
	0x74, 0x77, 0x71, 0xd3, 0x43, 0x7e, 0x58, 0x03, 0x91, 0x65, 0x82, 0x1b, 0xb3, 0xaa, 0xb8, 0xe9,
	0x83, 0x2d, 0x42, 0x3d, 0x08, 0x8a, 0x1f, 0x9b, 0x69, 0x6d, 0xda, 0x56, 0xc0, 0x53, 0x8f, 0xb8,
	0x75, 0xf5, 0x6d, 0x33, 0x76, 0x58, 0xe0, 0x5c, 0x5d, 0xf4, 0x61, 0x38, 0x74, 0x02, 0xed, 0x22,
	0xe8, 0xd2, 0xfa, 0x22, 0x0c, 0xac, 0xd4, 0xdd, 0x92, 0xd4, 0x77, 0x9c, 0x13, 0x17, 0x69, 0x1d,
	0x8c, 0x5e, 0xc0, 0xfd, 0x3b, 0x0f, 0xc3, 0x68, 0xc7, 0x94, 0x9a, 0x52, 0xe9, 0x87, 0xee, 0x11,
	0xea, 0x2f, 0xdf, 0x84, 0x9b, 0xe8, 0xff, 0x4a, 0x65, 0x96, 0x39, 0x96, 0x4f, 0x45, 0xc0, 0x96,
	0xe1, 0xd9, 0x25, 0x23, 0x58, 0xd3, 0xd3, 0x29, 0x1f, 0x3b, 0x5f, 0x91, 0x25, 0x59, 0xf8, 0xaa,
	0x44, 0xa1, 0x77, 0xa1, 0xc5, 0xb8, 0xa6, 0x32, 0xa3, 0x63, 0x86, 0x35, 0x55, 0xfe, 0x05, 0xae,
	0x92, 0x08, 0xc1, 0x9a, 0x14, 0x42, 0xfb, 0xd7, 0x6e, 0xcf, 0xd1, 0x77, 0x00, 0x4f, 0x6c, 0xaf,
	0xf6, 0x3b, 0xfe, 0xc3, 0x4a, 0xcb, 0xad, 0xb1, 0x56, 0xda, 0x1a, 0xd1, 0x10, 0xb6, 0x5d, 0x7d,
	0xe5, 0x36, 0x8c, 0xca, 0x05, 0x57, 0x14, 0x1d, 0xc1, 0x86, 0x93, 0x50, 0x85, 0x15, 0xbb, 0xcd,
	0x76, 0x96, 0xc2, 0x2d, 0xfb, 0x8d, 0x8b, 0xa0, 0xe8, 0xaf, 0x0a, 0x84, 0x03, 0x49, 0xb1, 0xa6,
	0x25, 0xf9, 0x8a, 0x7d, 0xf5, 0x19, 0xb4, 0xa5, 0x3b, 0x26, 0x97, 0x42, 0x66, 0xd8, 0x2d, 0x80,
	0xf6, 0x71, 0xb8, 0xcc, 0x39, 0xe4, 0x44, 0x8c, 0x19, 0x9f, 0x3c, 0xb6, 0xf7, 0x71, 0xcb, 0xc7,
	0x3b, 0x68, 0x56, 0x87, 0x27, 0x8a, 0xd5, 0xe6, 0x61, 0x79, 0xe9, 0xd5, 0x56, 0x96, 0x1e, 0x7a,
	0x1b, 0x9a, 0xae, 0xb9, 0xa4, 0xfc, 0xd5, 0x81, 0xe3, 0x9e, 0xda, 0x8d, 0xd9, 0x83, 0xe0, 0x15,
	0xd3, 0x57, 0xc9, 0xc8, 0x8e, 0xd9, 0x3e, 0xbb, 0x46, 0x0c, 0x86, 0xf2, 0x83, 0xdf, 0x81, 0xba,
	0x16, 0xd7, 0x94, 0xfb, 0x77, 0xe7, 0xc0, 0xfb, 0x0f, 0xa0, 0xbd, 0xda, 0x2e, 0xda, 0x80, 0xda,
	0xf9, 0xf0, 0x59, 0xe7, 0x9e, 0x39, 0x3c, 0x1a, 0xc6, 0x9d, 0x0a, 0xda, 0x84, 0xfa, 0xf9, 0x17,
	0x83, 0x8b, 0x8f, 0x3b, 0xd5, 0xe3, 0x5f, 0xaa, 0xd0, 0x39, 0x99, 0xea, 0x2b, 0x21, 0x99, 0x9e,
	0x5f, 0x50, 0xf9, 0x92, 0x11, 0x8a, 0xae, 0x21, 0x28, 0xfb, 0xf7, 0xe0, 0x5f, 0x6d, 0x59, 0xda,
	0xf9, 0xdd, 0xbd, 0xd7, 0x46, 0x44, 0xbd, 0xef, 0x7f, 0xfb, 0xf3, 0x87, 0xea, 0x5e, 0xf4, 0xff,
	0xfe, 0xcb, 0x0f, 0xfb, 0x04, 0xf7, 0x89, 0x92, 0x7d, 0xaf, 0x42, 0xc2, 0x4c, 0x76, 0x63, 0xea,
	0xbb, 0xb3, 0x41, 0x51, 0x29, 0xe1, 0x6b, 0x06, 0xd7, 0x7d, 0x63, 0xb5, 0xe8, 0xca, 0xab, 0x88,
	0xf6, 0x6c, 0xd9, 0xed, 0x68, 0xab, 0x54, 0x96, 0xd8, 0x4c, 0xe8, 0x39, 0x6c, 0x78, 0x53, 0xa1,
	0xd2, 0x0a, 0x1d, 0x66, 0xb9, 0x9e, 0x17, 0xa9, 0xdf, 0xba, 0xeb, 0xa7, 0x15, 0xff, 0x45, 0xbb,
	0x36, 0x79, 0x07, 0xb5, 0x7d, 0x72, 0xef, 0xb3, 0xd3, 0xce, 0xcf, 0x8b, 0xfd, 0xca, 0xaf, 0x8b,
	0xfd, 0xca, 0xef, 0x8b, 0xfd, 0xca, 0x8f, 0x7f, 0xec, 0xdf, 0x1b, 0xad, 0xdb, 0x7f, 0x12, 0x0f,
	0xff, 0x09, 0x00, 0x00, 0xff, 0xff, 0x26, 0x7a, 0x79, 0x49, 0xa0, 0x08, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AuthorityServiceClient is the client API for AuthorityService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AuthorityServiceClient interface {
	// ProfileInfo returns the certificate profile info
	ProfileInfo(ctx context.Context, in *CertProfileInfoRequest, opts ...grpc.CallOption) (*CertProfileInfo, error)
	// CreateCertificate returns the certificate
	CreateCertificate(ctx context.Context, in *CreateCertificateRequest, opts ...grpc.CallOption) (*CertificateBundle, error)
	// Issuers returns the issuing CAs
	Issuers(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*IssuersInfoResponse, error)
}

type authorityServiceClient struct {
	cc *grpc.ClientConn
}

func NewAuthorityServiceClient(cc *grpc.ClientConn) AuthorityServiceClient {
	return &authorityServiceClient{cc}
}

func (c *authorityServiceClient) ProfileInfo(ctx context.Context, in *CertProfileInfoRequest, opts ...grpc.CallOption) (*CertProfileInfo, error) {
	out := new(CertProfileInfo)
	err := c.cc.Invoke(ctx, "/trustypb.AuthorityService/ProfileInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authorityServiceClient) CreateCertificate(ctx context.Context, in *CreateCertificateRequest, opts ...grpc.CallOption) (*CertificateBundle, error) {
	out := new(CertificateBundle)
	err := c.cc.Invoke(ctx, "/trustypb.AuthorityService/CreateCertificate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authorityServiceClient) Issuers(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*IssuersInfoResponse, error) {
	out := new(IssuersInfoResponse)
	err := c.cc.Invoke(ctx, "/trustypb.AuthorityService/Issuers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthorityServiceServer is the server API for AuthorityService service.
type AuthorityServiceServer interface {
	// ProfileInfo returns the certificate profile info
	ProfileInfo(context.Context, *CertProfileInfoRequest) (*CertProfileInfo, error)
	// CreateCertificate returns the certificate
	CreateCertificate(context.Context, *CreateCertificateRequest) (*CertificateBundle, error)
	// Issuers returns the issuing CAs
	Issuers(context.Context, *EmptyRequest) (*IssuersInfoResponse, error)
}

// UnimplementedAuthorityServiceServer can be embedded to have forward compatible implementations.
type UnimplementedAuthorityServiceServer struct {
}

func (*UnimplementedAuthorityServiceServer) ProfileInfo(ctx context.Context, req *CertProfileInfoRequest) (*CertProfileInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProfileInfo not implemented")
}
func (*UnimplementedAuthorityServiceServer) CreateCertificate(ctx context.Context, req *CreateCertificateRequest) (*CertificateBundle, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCertificate not implemented")
}
func (*UnimplementedAuthorityServiceServer) Issuers(ctx context.Context, req *EmptyRequest) (*IssuersInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Issuers not implemented")
}

func RegisterAuthorityServiceServer(s *grpc.Server, srv AuthorityServiceServer) {
	s.RegisterService(&_AuthorityService_serviceDesc, srv)
}

func _AuthorityService_ProfileInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CertProfileInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthorityServiceServer).ProfileInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trustypb.AuthorityService/ProfileInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthorityServiceServer).ProfileInfo(ctx, req.(*CertProfileInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthorityService_CreateCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCertificateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthorityServiceServer).CreateCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trustypb.AuthorityService/CreateCertificate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthorityServiceServer).CreateCertificate(ctx, req.(*CreateCertificateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthorityService_Issuers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthorityServiceServer).Issuers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trustypb.AuthorityService/Issuers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthorityServiceServer).Issuers(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _AuthorityService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "trustypb.AuthorityService",
	HandlerType: (*AuthorityServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ProfileInfo",
			Handler:    _AuthorityService_ProfileInfo_Handler,
		},
		{
			MethodName: "CreateCertificate",
			Handler:    _AuthorityService_CreateCertificate_Handler,
		},
		{
			MethodName: "Issuers",
			Handler:    _AuthorityService_Issuers_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkix.proto",
}

func (m *X509Name) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *X509Name) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *X509Name) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.OrganisationalUnit) > 0 {
		i -= len(m.OrganisationalUnit)
		copy(dAtA[i:], m.OrganisationalUnit)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.OrganisationalUnit)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Organisation) > 0 {
		i -= len(m.Organisation)
		copy(dAtA[i:], m.Organisation)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Organisation)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Locality) > 0 {
		i -= len(m.Locality)
		copy(dAtA[i:], m.Locality)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Locality)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Country) > 0 {
		i -= len(m.Country)
		copy(dAtA[i:], m.Country)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Country)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *X509Subject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *X509Subject) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *X509Subject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SerialNumber) > 0 {
		i -= len(m.SerialNumber)
		copy(dAtA[i:], m.SerialNumber)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.SerialNumber)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Names) > 0 {
		for iNdEx := len(m.Names) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Names[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPkix(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Cn) > 0 {
		i -= len(m.Cn)
		copy(dAtA[i:], m.Cn)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Cn)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CertProfileInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CertProfileInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CertProfileInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Profile) > 0 {
		i -= len(m.Profile)
		copy(dAtA[i:], m.Profile)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Profile)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Label) > 0 {
		i -= len(m.Label)
		copy(dAtA[i:], m.Label)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Label)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CAConstraint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CAConstraint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CAConstraint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MaxPathLenZero != 0 {
		i = encodeVarintPkix(dAtA, i, uint64(m.MaxPathLenZero))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxPathLen != 0 {
		i = encodeVarintPkix(dAtA, i, uint64(m.MaxPathLen))
		i--
		dAtA[i] = 0x10
	}
	if m.IsCa {
		i--
		if m.IsCa {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CSRAllowedFields) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSRAllowedFields) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CSRAllowedFields) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Email {
		i--
		if m.Email {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Ip {
		i--
		if m.Ip {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Dns {
		i--
		if m.Dns {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Subject {
		i--
		if m.Subject {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CertProfile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CertProfile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CertProfile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AllowedFields != nil {
		{
			size, err := m.AllowedFields.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPkix(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.AllowedEmail) > 0 {
		i -= len(m.AllowedEmail)
		copy(dAtA[i:], m.AllowedEmail)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.AllowedEmail)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.AllowedDns) > 0 {
		i -= len(m.AllowedDns)
		copy(dAtA[i:], m.AllowedDns)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.AllowedDns)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.AllowedCommonNames) > 0 {
		i -= len(m.AllowedCommonNames)
		copy(dAtA[i:], m.AllowedCommonNames)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.AllowedCommonNames)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.AllowedExtensions) > 0 {
		for iNdEx := len(m.AllowedExtensions) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowedExtensions[iNdEx])
			copy(dAtA[i:], m.AllowedExtensions[iNdEx])
			i = encodeVarintPkix(dAtA, i, uint64(len(m.AllowedExtensions[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Backdate) > 0 {
		i -= len(m.Backdate)
		copy(dAtA[i:], m.Backdate)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Backdate)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Expiry) > 0 {
		i -= len(m.Expiry)
		copy(dAtA[i:], m.Expiry)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Expiry)))
		i--
		dAtA[i] = 0x2a
	}
	if m.OCSPNoCheck {
		i--
		if m.OCSPNoCheck {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.CAConstraint != nil {
		{
			size, err := m.CAConstraint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPkix(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Usages) > 0 {
		for iNdEx := len(m.Usages) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Usages[iNdEx])
			copy(dAtA[i:], m.Usages[iNdEx])
			i = encodeVarintPkix(dAtA, i, uint64(len(m.Usages[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CertProfileInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CertProfileInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CertProfileInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Profile != nil {
		{
			size, err := m.Profile.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPkix(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Issuer) > 0 {
		i -= len(m.Issuer)
		copy(dAtA[i:], m.Issuer)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Issuer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CertificateBundle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CertificateBundle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CertificateBundle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Root) > 0 {
		i -= len(m.Root)
		copy(dAtA[i:], m.Root)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Root)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Intermediates) > 0 {
		i -= len(m.Intermediates)
		copy(dAtA[i:], m.Intermediates)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Intermediates)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Certificate) > 0 {
		i -= len(m.Certificate)
		copy(dAtA[i:], m.Certificate)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Certificate)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IssuerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IssuerInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IssuerInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Label) > 0 {
		i -= len(m.Label)
		copy(dAtA[i:], m.Label)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Label)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Root) > 0 {
		i -= len(m.Root)
		copy(dAtA[i:], m.Root)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Root)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Intermediates) > 0 {
		i -= len(m.Intermediates)
		copy(dAtA[i:], m.Intermediates)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Intermediates)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Certificate) > 0 {
		i -= len(m.Certificate)
		copy(dAtA[i:], m.Certificate)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Certificate)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IssuersInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IssuersInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IssuersInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Issuers) > 0 {
		for iNdEx := len(m.Issuers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Issuers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPkix(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateCertificateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateCertificateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateCertificateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x32
	}
	if m.WithBundle {
		i--
		if m.WithBundle {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.IssuerLabel) > 0 {
		i -= len(m.IssuerLabel)
		copy(dAtA[i:], m.IssuerLabel)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.IssuerLabel)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Profile) > 0 {
		i -= len(m.Profile)
		copy(dAtA[i:], m.Profile)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Profile)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Request) > 0 {
		i -= len(m.Request)
		copy(dAtA[i:], m.Request)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Request)))
		i--
		dAtA[i] = 0x12
	}
	if m.RequestFormat != 0 {
		i = encodeVarintPkix(dAtA, i, uint64(m.RequestFormat))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintPkix(dAtA []byte, offset int, v uint64) int {
	offset -= sovPkix(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *X509Name) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Country)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	l = len(m.Locality)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	l = len(m.Organisation)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	l = len(m.OrganisationalUnit)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *X509Subject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Cn)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	if len(m.Names) > 0 {
		for _, e := range m.Names {
			l = e.Size()
			n += 1 + l + sovPkix(uint64(l))
		}
	}
	l = len(m.SerialNumber)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CertProfileInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	l = len(m.Profile)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CAConstraint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsCa {
		n += 2
	}
	if m.MaxPathLen != 0 {
		n += 1 + sovPkix(uint64(m.MaxPathLen))
	}
	if m.MaxPathLenZero != 0 {
		n += 1 + sovPkix(uint64(m.MaxPathLenZero))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CSRAllowedFields) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Subject {
		n += 2
	}
	if m.Dns {
		n += 2
	}
	if m.Ip {
		n += 2
	}
	if m.Email {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CertProfile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	if len(m.Usages) > 0 {
		for _, s := range m.Usages {
			l = len(s)
			n += 1 + l + sovPkix(uint64(l))
		}
	}
	if m.CAConstraint != nil {
		l = m.CAConstraint.Size()
		n += 1 + l + sovPkix(uint64(l))
	}
	if m.OCSPNoCheck {
		n += 2
	}
	l = len(m.Expiry)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	l = len(m.Backdate)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	if len(m.AllowedExtensions) > 0 {
		for _, s := range m.AllowedExtensions {
			l = len(s)
			n += 1 + l + sovPkix(uint64(l))
		}
	}
	l = len(m.AllowedCommonNames)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	l = len(m.AllowedDns)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	l = len(m.AllowedEmail)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	if m.AllowedFields != nil {
		l = m.AllowedFields.Size()
		n += 1 + l + sovPkix(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CertProfileInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	if m.Profile != nil {
		l = m.Profile.Size()
		n += 1 + l + sovPkix(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CertificateBundle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Certificate)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	l = len(m.Intermediates)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	l = len(m.Root)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IssuerInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Certificate)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	l = len(m.Intermediates)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	l = len(m.Root)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IssuersInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Issuers) > 0 {
		for _, e := range m.Issuers {
			l = e.Size()
			n += 1 + l + sovPkix(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateCertificateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestFormat != 0 {
		n += 1 + sovPkix(uint64(m.RequestFormat))
	}
	l = len(m.Request)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	l = len(m.Profile)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	l = len(m.IssuerLabel)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	if m.WithBundle {
		n += 2
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovPkix(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPkix(x uint64) (n int) {
	return sovPkix(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *X509Name) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPkix
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: X509Name: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: X509Name: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Country = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locality", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locality = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Organisation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Organisation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrganisationalUnit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrganisationalUnit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPkix(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPkix
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *X509Subject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPkix
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: X509Subject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: X509Subject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Names", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Names = append(m.Names, &X509Name{})
			if err := m.Names[len(m.Names)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SerialNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPkix(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPkix
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CertProfileInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPkix
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CertProfileInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CertProfileInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Profile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPkix(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPkix
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CAConstraint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPkix
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CAConstraint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CAConstraint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCa", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCa = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPathLen", wireType)
			}
			m.MaxPathLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxPathLen |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPathLenZero", wireType)
			}
			m.MaxPathLenZero = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxPathLenZero |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPkix(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPkix
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSRAllowedFields) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPkix
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSRAllowedFields: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSRAllowedFields: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Subject = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dns", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dns = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ip = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Email = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPkix(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPkix
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CertProfile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPkix
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CertProfile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CertProfile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Usages", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Usages = append(m.Usages, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CAConstraint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CAConstraint == nil {
				m.CAConstraint = &CAConstraint{}
			}
			if err := m.CAConstraint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OCSPNoCheck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OCSPNoCheck = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiry", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expiry = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Backdate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Backdate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedExtensions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedExtensions = append(m.AllowedExtensions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedCommonNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedCommonNames = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedDns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedDns = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedEmail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedEmail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedFields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AllowedFields == nil {
				m.AllowedFields = &CSRAllowedFields{}
			}
			if err := m.AllowedFields.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPkix(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPkix
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CertProfileInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPkix
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CertProfileInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CertProfileInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Profile == nil {
				m.Profile = &CertProfile{}
			}
			if err := m.Profile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPkix(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPkix
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CertificateBundle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPkix
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CertificateBundle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CertificateBundle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Certificate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Certificate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intermediates", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Intermediates = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Root = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPkix(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPkix
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IssuerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPkix
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IssuerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IssuerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Certificate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Certificate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intermediates", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Intermediates = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Root = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPkix(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPkix
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IssuersInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPkix
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IssuersInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IssuersInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuers = append(m.Issuers, &IssuerInfo{})
			if err := m.Issuers[len(m.Issuers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPkix(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPkix
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateCertificateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPkix
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateCertificateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateCertificateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestFormat", wireType)
			}
			m.RequestFormat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestFormat |= EncodingFormat(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Profile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IssuerLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IssuerLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithBundle", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithBundle = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPkix(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPkix
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPkix(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPkix
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPkix
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPkix
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPkix
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPkix        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPkix          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPkix = fmt.Errorf("proto: unexpected end of group")
)
