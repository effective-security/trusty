// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pkix.proto

package trustypb

import (
	context "context"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type EncodingFormat int32

const (
	EncodingFormat_PEM   EncodingFormat = 0
	EncodingFormat_DER   EncodingFormat = 1
	EncodingFormat_PKCS7 EncodingFormat = 2
)

var EncodingFormat_name = map[int32]string{
	0: "PEM",
	1: "DER",
	2: "PKCS7",
}

var EncodingFormat_value = map[string]int32{
	"PEM":   0,
	"DER":   1,
	"PKCS7": 2,
}

func (x EncodingFormat) String() string {
	return proto.EnumName(EncodingFormat_name, int32(x))
}

func (EncodingFormat) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b687f69c61c1b2df, []int{0}
}

type Trust int32

const (
	Trust_Public  Trust = 0
	Trust_Private Trust = 1
	Trust_Org     Trust = 2
)

var Trust_name = map[int32]string{
	0: "Public",
	1: "Private",
	2: "Org",
}

var Trust_value = map[string]int32{
	"Public":  0,
	"Private": 1,
	"Org":     2,
}

func (x Trust) String() string {
	return proto.EnumName(Trust_name, int32(x))
}

func (Trust) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b687f69c61c1b2df, []int{1}
}

// X509Name specifies X509 Name
type X509Name struct {
	Country              string   `protobuf:"bytes,1,opt,name=country,proto3" json:"country,omitempty"`
	State                string   `protobuf:"bytes,2,opt,name=state,proto3" json:"state,omitempty"`
	Locality             string   `protobuf:"bytes,3,opt,name=locality,proto3" json:"locality,omitempty"`
	Organisation         string   `protobuf:"bytes,4,opt,name=organisation,proto3" json:"organisation,omitempty"`
	OrganisationalUnit   string   `protobuf:"bytes,5,opt,name=organisational_unit,json=organisationalUnit,proto3" json:"organisational_unit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *X509Name) Reset()         { *m = X509Name{} }
func (m *X509Name) String() string { return proto.CompactTextString(m) }
func (*X509Name) ProtoMessage()    {}
func (*X509Name) Descriptor() ([]byte, []int) {
	return fileDescriptor_b687f69c61c1b2df, []int{0}
}
func (m *X509Name) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *X509Name) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_X509Name.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *X509Name) XXX_Merge(src proto.Message) {
	xxx_messageInfo_X509Name.Merge(m, src)
}
func (m *X509Name) XXX_Size() int {
	return m.Size()
}
func (m *X509Name) XXX_DiscardUnknown() {
	xxx_messageInfo_X509Name.DiscardUnknown(m)
}

var xxx_messageInfo_X509Name proto.InternalMessageInfo

func (m *X509Name) GetCountry() string {
	if m != nil {
		return m.Country
	}
	return ""
}

func (m *X509Name) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *X509Name) GetLocality() string {
	if m != nil {
		return m.Locality
	}
	return ""
}

func (m *X509Name) GetOrganisation() string {
	if m != nil {
		return m.Organisation
	}
	return ""
}

func (m *X509Name) GetOrganisationalUnit() string {
	if m != nil {
		return m.OrganisationalUnit
	}
	return ""
}

// X509Subject specifies X509 Subject
type X509Subject struct {
	Cn                   string      `protobuf:"bytes,1,opt,name=cn,proto3" json:"cn,omitempty"`
	Names                []*X509Name `protobuf:"bytes,2,rep,name=names,proto3" json:"names,omitempty"`
	SerialNumber         string      `protobuf:"bytes,3,opt,name=serial_number,json=serialNumber,proto3" json:"serial_number,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *X509Subject) Reset()         { *m = X509Subject{} }
func (m *X509Subject) String() string { return proto.CompactTextString(m) }
func (*X509Subject) ProtoMessage()    {}
func (*X509Subject) Descriptor() ([]byte, []int) {
	return fileDescriptor_b687f69c61c1b2df, []int{1}
}
func (m *X509Subject) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *X509Subject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_X509Subject.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *X509Subject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_X509Subject.Merge(m, src)
}
func (m *X509Subject) XXX_Size() int {
	return m.Size()
}
func (m *X509Subject) XXX_DiscardUnknown() {
	xxx_messageInfo_X509Subject.DiscardUnknown(m)
}

var xxx_messageInfo_X509Subject proto.InternalMessageInfo

func (m *X509Subject) GetCn() string {
	if m != nil {
		return m.Cn
	}
	return ""
}

func (m *X509Subject) GetNames() []*X509Name {
	if m != nil {
		return m.Names
	}
	return nil
}

func (m *X509Subject) GetSerialNumber() string {
	if m != nil {
		return m.SerialNumber
	}
	return ""
}

type CertProfileInfoRequest struct {
	Label                string   `protobuf:"bytes,1,opt,name=label,proto3" json:"label,omitempty"`
	Profile              string   `protobuf:"bytes,2,opt,name=profile,proto3" json:"profile,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CertProfileInfoRequest) Reset()         { *m = CertProfileInfoRequest{} }
func (m *CertProfileInfoRequest) String() string { return proto.CompactTextString(m) }
func (*CertProfileInfoRequest) ProtoMessage()    {}
func (*CertProfileInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b687f69c61c1b2df, []int{2}
}
func (m *CertProfileInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CertProfileInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CertProfileInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CertProfileInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertProfileInfoRequest.Merge(m, src)
}
func (m *CertProfileInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *CertProfileInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CertProfileInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CertProfileInfoRequest proto.InternalMessageInfo

func (m *CertProfileInfoRequest) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *CertProfileInfoRequest) GetProfile() string {
	if m != nil {
		return m.Profile
	}
	return ""
}

// CertProfileInfo is the response for an Profile Info API request
type CertProfileInfo struct {
	Issuer               string   `protobuf:"bytes,1,opt,name=issuer,proto3" json:"issuer,omitempty"`
	Usage                []string `protobuf:"bytes,2,rep,name=usage,proto3" json:"usage,omitempty"`
	Expiry               string   `protobuf:"bytes,3,opt,name=expiry,proto3" json:"expiry,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CertProfileInfo) Reset()         { *m = CertProfileInfo{} }
func (m *CertProfileInfo) String() string { return proto.CompactTextString(m) }
func (*CertProfileInfo) ProtoMessage()    {}
func (*CertProfileInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_b687f69c61c1b2df, []int{3}
}
func (m *CertProfileInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CertProfileInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CertProfileInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CertProfileInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertProfileInfo.Merge(m, src)
}
func (m *CertProfileInfo) XXX_Size() int {
	return m.Size()
}
func (m *CertProfileInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CertProfileInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CertProfileInfo proto.InternalMessageInfo

func (m *CertProfileInfo) GetIssuer() string {
	if m != nil {
		return m.Issuer
	}
	return ""
}

func (m *CertProfileInfo) GetUsage() []string {
	if m != nil {
		return m.Usage
	}
	return nil
}

func (m *CertProfileInfo) GetExpiry() string {
	if m != nil {
		return m.Expiry
	}
	return ""
}

// CertificateBundle provides certificate and its issuers
type CertificateBundle struct {
	// Certificate provides the certificate in PEM format
	Certificate string `protobuf:"bytes,1,opt,name=certificate,proto3" json:"certificate,omitempty"`
	// Intermediates provides the intermediate CA certificates bundle in PEM format
	Intermediates string `protobuf:"bytes,2,opt,name=intermediates,proto3" json:"intermediates,omitempty"`
	// Root provides the Root CA certifica in PEM format
	Root                 string   `protobuf:"bytes,3,opt,name=root,proto3" json:"root,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CertificateBundle) Reset()         { *m = CertificateBundle{} }
func (m *CertificateBundle) String() string { return proto.CompactTextString(m) }
func (*CertificateBundle) ProtoMessage()    {}
func (*CertificateBundle) Descriptor() ([]byte, []int) {
	return fileDescriptor_b687f69c61c1b2df, []int{4}
}
func (m *CertificateBundle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CertificateBundle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CertificateBundle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CertificateBundle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertificateBundle.Merge(m, src)
}
func (m *CertificateBundle) XXX_Size() int {
	return m.Size()
}
func (m *CertificateBundle) XXX_DiscardUnknown() {
	xxx_messageInfo_CertificateBundle.DiscardUnknown(m)
}

var xxx_messageInfo_CertificateBundle proto.InternalMessageInfo

func (m *CertificateBundle) GetCertificate() string {
	if m != nil {
		return m.Certificate
	}
	return ""
}

func (m *CertificateBundle) GetIntermediates() string {
	if m != nil {
		return m.Intermediates
	}
	return ""
}

func (m *CertificateBundle) GetRoot() string {
	if m != nil {
		return m.Root
	}
	return ""
}

// IssuerInfo provides Issuer information
type IssuerInfo struct {
	// Certificate provides the certificate in PEM format
	Certificate string `protobuf:"bytes,1,opt,name=certificate,proto3" json:"certificate,omitempty"`
	// Intermediates provides the intermediate CA certificates bundle in PEM format
	Intermediates string `protobuf:"bytes,2,opt,name=intermediates,proto3" json:"intermediates,omitempty"`
	// Root provides the Root CA certificate in PEM format
	Root string `protobuf:"bytes,3,opt,name=root,proto3" json:"root,omitempty"`
	// Label specifies the Issuer's label
	Label                string   `protobuf:"bytes,4,opt,name=label,proto3" json:"label,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IssuerInfo) Reset()         { *m = IssuerInfo{} }
func (m *IssuerInfo) String() string { return proto.CompactTextString(m) }
func (*IssuerInfo) ProtoMessage()    {}
func (*IssuerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_b687f69c61c1b2df, []int{5}
}
func (m *IssuerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IssuerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IssuerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IssuerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IssuerInfo.Merge(m, src)
}
func (m *IssuerInfo) XXX_Size() int {
	return m.Size()
}
func (m *IssuerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_IssuerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_IssuerInfo proto.InternalMessageInfo

func (m *IssuerInfo) GetCertificate() string {
	if m != nil {
		return m.Certificate
	}
	return ""
}

func (m *IssuerInfo) GetIntermediates() string {
	if m != nil {
		return m.Intermediates
	}
	return ""
}

func (m *IssuerInfo) GetRoot() string {
	if m != nil {
		return m.Root
	}
	return ""
}

func (m *IssuerInfo) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

// IssuersInfoResponse provides response for Issuers Info request
type IssuersInfoResponse struct {
	Issuers              []*IssuerInfo `protobuf:"bytes,1,rep,name=issuers,proto3" json:"issuers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *IssuersInfoResponse) Reset()         { *m = IssuersInfoResponse{} }
func (m *IssuersInfoResponse) String() string { return proto.CompactTextString(m) }
func (*IssuersInfoResponse) ProtoMessage()    {}
func (*IssuersInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b687f69c61c1b2df, []int{6}
}
func (m *IssuersInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IssuersInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IssuersInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IssuersInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IssuersInfoResponse.Merge(m, src)
}
func (m *IssuersInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *IssuersInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_IssuersInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_IssuersInfoResponse proto.InternalMessageInfo

func (m *IssuersInfoResponse) GetIssuers() []*IssuerInfo {
	if m != nil {
		return m.Issuers
	}
	return nil
}

// CreateCertificateRequest specifies certificate request
type CreateCertificateRequest struct {
	// RequestFormat provides the certificate request format: CSR, CMS
	RequestFormat EncodingFormat `protobuf:"varint,1,opt,name=request_format,json=requestFormat,proto3,enum=trustypb.EncodingFormat" json:"request_format,omitempty"`
	// Request provides the certificate request
	Request string `protobuf:"bytes,2,opt,name=request,proto3" json:"request,omitempty"`
	// Profile specifies the certificate profile: client, server, spiffe
	Profile string `protobuf:"bytes,3,opt,name=profile,proto3" json:"profile,omitempty"`
	// IssuerLabel specifies which Issuer to be appointed to sign the request
	IssuerLabel string `protobuf:"bytes,4,opt,name=issuer_label,json=issuerLabel,proto3" json:"issuer_label,omitempty"`
	// WithBundle specifies whether to include an "optimal" certificate bundle along with the certificate
	WithBundle bool `protobuf:"varint,5,opt,name=with_bundle,json=withBundle,proto3" json:"with_bundle,omitempty"`
	// Token provides the authorization token for the request
	Token                string   `protobuf:"bytes,6,opt,name=token,proto3" json:"token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateCertificateRequest) Reset()         { *m = CreateCertificateRequest{} }
func (m *CreateCertificateRequest) String() string { return proto.CompactTextString(m) }
func (*CreateCertificateRequest) ProtoMessage()    {}
func (*CreateCertificateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b687f69c61c1b2df, []int{7}
}
func (m *CreateCertificateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateCertificateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateCertificateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateCertificateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateCertificateRequest.Merge(m, src)
}
func (m *CreateCertificateRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateCertificateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateCertificateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateCertificateRequest proto.InternalMessageInfo

func (m *CreateCertificateRequest) GetRequestFormat() EncodingFormat {
	if m != nil {
		return m.RequestFormat
	}
	return EncodingFormat_PEM
}

func (m *CreateCertificateRequest) GetRequest() string {
	if m != nil {
		return m.Request
	}
	return ""
}

func (m *CreateCertificateRequest) GetProfile() string {
	if m != nil {
		return m.Profile
	}
	return ""
}

func (m *CreateCertificateRequest) GetIssuerLabel() string {
	if m != nil {
		return m.IssuerLabel
	}
	return ""
}

func (m *CreateCertificateRequest) GetWithBundle() bool {
	if m != nil {
		return m.WithBundle
	}
	return false
}

func (m *CreateCertificateRequest) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

// Root provides X509 Root Cert information
type RootCertificate struct {
	// ID of the certificate
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// OwnerID of the certificate, only used with Org scope
	OwnerId int64 `protobuf:"varint,2,opt,name=owner_id,json=ownerId,proto3" json:"owner_id,omitempty"`
	// Skid provides Subject Key Identifier
	Skid string `protobuf:"bytes,3,opt,name=skid,proto3" json:"skid,omitempty"`
	// Notbefore is the Unix time when the validity period starts
	Notbefore int64 `protobuf:"varint,4,opt,name=notbefore,proto3" json:"notbefore,omitempty"`
	// Notafter is the Unix time when the validity period starts
	Notafter int64 `protobuf:"varint,5,opt,name=notafter,proto3" json:"notafter,omitempty"`
	//Issuer name
	Issuer string `protobuf:"bytes,6,opt,name=issuer,proto3" json:"issuer,omitempty"`
	// SHA256 thnumbprint of the cert
	Sha256 string `protobuf:"bytes,7,opt,name=sha256,proto3" json:"sha256,omitempty"`
	// Trust scope
	Trust Trust `protobuf:"varint,8,opt,name=trust,proto3,enum=trustypb.Trust" json:"trust,omitempty"`
	// PEM encoded certificate
	Pem                  string   `protobuf:"bytes,9,opt,name=pem,proto3" json:"pem,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RootCertificate) Reset()         { *m = RootCertificate{} }
func (m *RootCertificate) String() string { return proto.CompactTextString(m) }
func (*RootCertificate) ProtoMessage()    {}
func (*RootCertificate) Descriptor() ([]byte, []int) {
	return fileDescriptor_b687f69c61c1b2df, []int{8}
}
func (m *RootCertificate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RootCertificate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RootCertificate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RootCertificate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RootCertificate.Merge(m, src)
}
func (m *RootCertificate) XXX_Size() int {
	return m.Size()
}
func (m *RootCertificate) XXX_DiscardUnknown() {
	xxx_messageInfo_RootCertificate.DiscardUnknown(m)
}

var xxx_messageInfo_RootCertificate proto.InternalMessageInfo

func (m *RootCertificate) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RootCertificate) GetOwnerId() int64 {
	if m != nil {
		return m.OwnerId
	}
	return 0
}

func (m *RootCertificate) GetSkid() string {
	if m != nil {
		return m.Skid
	}
	return ""
}

func (m *RootCertificate) GetNotbefore() int64 {
	if m != nil {
		return m.Notbefore
	}
	return 0
}

func (m *RootCertificate) GetNotafter() int64 {
	if m != nil {
		return m.Notafter
	}
	return 0
}

func (m *RootCertificate) GetIssuer() string {
	if m != nil {
		return m.Issuer
	}
	return ""
}

func (m *RootCertificate) GetSha256() string {
	if m != nil {
		return m.Sha256
	}
	return ""
}

func (m *RootCertificate) GetTrust() Trust {
	if m != nil {
		return m.Trust
	}
	return Trust_Public
}

func (m *RootCertificate) GetPem() string {
	if m != nil {
		return m.Pem
	}
	return ""
}

func init() {
	proto.RegisterEnum("trustypb.EncodingFormat", EncodingFormat_name, EncodingFormat_value)
	proto.RegisterEnum("trustypb.Trust", Trust_name, Trust_value)
	proto.RegisterType((*X509Name)(nil), "trustypb.X509Name")
	proto.RegisterType((*X509Subject)(nil), "trustypb.X509Subject")
	proto.RegisterType((*CertProfileInfoRequest)(nil), "trustypb.CertProfileInfoRequest")
	proto.RegisterType((*CertProfileInfo)(nil), "trustypb.CertProfileInfo")
	proto.RegisterType((*CertificateBundle)(nil), "trustypb.CertificateBundle")
	proto.RegisterType((*IssuerInfo)(nil), "trustypb.IssuerInfo")
	proto.RegisterType((*IssuersInfoResponse)(nil), "trustypb.IssuersInfoResponse")
	proto.RegisterType((*CreateCertificateRequest)(nil), "trustypb.CreateCertificateRequest")
	proto.RegisterType((*RootCertificate)(nil), "trustypb.RootCertificate")
}

func init() { proto.RegisterFile("pkix.proto", fileDescriptor_b687f69c61c1b2df) }

var fileDescriptor_b687f69c61c1b2df = []byte{
	// 866 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x55, 0xcd, 0x6e, 0xe4, 0x44,
	0x10, 0x8e, 0xed, 0xcc, 0x5f, 0x4d, 0x32, 0xf1, 0x76, 0xa2, 0xc1, 0x19, 0x96, 0x6c, 0x68, 0x40,
	0x0a, 0x2b, 0x91, 0x81, 0xa0, 0x05, 0x71, 0x42, 0x6c, 0x08, 0x22, 0x02, 0x96, 0x91, 0x17, 0xc4,
	0xde, 0x46, 0x3d, 0x9e, 0x9e, 0x49, 0x13, 0x4f, 0xb7, 0xe9, 0x6e, 0xef, 0x6e, 0x2e, 0x1c, 0x78,
	0x05, 0x2e, 0xbc, 0x03, 0x8f, 0xc1, 0x85, 0x23, 0x12, 0x2f, 0x80, 0x02, 0x17, 0xce, 0xbc, 0x00,
	0xea, 0x1f, 0xef, 0xd8, 0x11, 0x39, 0x72, 0xab, 0xef, 0xeb, 0xf2, 0x57, 0xd5, 0xf5, 0xd3, 0x06,
	0x28, 0x2e, 0xd9, 0xf3, 0xe3, 0x42, 0x0a, 0x2d, 0x50, 0x57, 0xcb, 0x52, 0xe9, 0xab, 0x62, 0x36,
	0xea, 0xc9, 0x22, 0x73, 0xe4, 0x68, 0x6f, 0x29, 0x96, 0xc2, 0x9a, 0x63, 0x63, 0x79, 0xf6, 0xee,
	0x52, 0x88, 0x65, 0x4e, 0xc7, 0xa4, 0x60, 0x63, 0xc2, 0xb9, 0xd0, 0x44, 0x33, 0xc1, 0x95, 0x3b,
	0xc5, 0x3f, 0x07, 0xd0, 0x7d, 0xf2, 0xe0, 0xed, 0x0f, 0x1e, 0x91, 0x15, 0x45, 0x09, 0x74, 0x32,
	0x51, 0x72, 0x2d, 0xaf, 0x92, 0xe0, 0x30, 0x38, 0xea, 0xa5, 0x15, 0x44, 0x7b, 0xd0, 0x52, 0x9a,
	0x68, 0x9a, 0x84, 0x96, 0x77, 0x00, 0x8d, 0xa0, 0x9b, 0x8b, 0x8c, 0xe4, 0x4c, 0x5f, 0x25, 0x91,
	0x3d, 0x78, 0x81, 0x11, 0x86, 0x2d, 0x21, 0x97, 0x84, 0x33, 0x65, 0xe3, 0x25, 0x9b, 0xf6, 0xbc,
	0xc1, 0xa1, 0x31, 0xec, 0xd6, 0x31, 0xc9, 0xa7, 0x25, 0x67, 0x3a, 0x69, 0x59, 0x57, 0xd4, 0x3c,
	0xfa, 0x9a, 0x33, 0x8d, 0x73, 0xe8, 0x9b, 0x64, 0x1f, 0x97, 0xb3, 0x6f, 0x69, 0xa6, 0xd1, 0x00,
	0xc2, 0x8c, 0xfb, 0x54, 0xc3, 0x8c, 0xa3, 0x23, 0x68, 0x71, 0xb2, 0xa2, 0x2a, 0x09, 0x0f, 0xa3,
	0xa3, 0xfe, 0x09, 0x3a, 0xae, 0xaa, 0x74, 0x5c, 0x5d, 0x31, 0x75, 0x0e, 0xe8, 0x35, 0xd8, 0x56,
	0x54, 0x32, 0x92, 0x4f, 0x79, 0xb9, 0x9a, 0x51, 0xe9, 0xd3, 0xdf, 0x72, 0xe4, 0x23, 0xcb, 0xe1,
	0x4f, 0x61, 0x78, 0x4a, 0xa5, 0x9e, 0x48, 0xb1, 0x60, 0x39, 0x3d, 0xe7, 0x0b, 0x91, 0xd2, 0xef,
	0x4a, 0xaa, 0xb4, 0x29, 0x47, 0x4e, 0x66, 0x34, 0xf7, 0xb1, 0x1d, 0x30, 0xe5, 0x2b, 0x9c, 0xaf,
	0x2f, 0x53, 0x05, 0xf1, 0x37, 0xb0, 0x73, 0x43, 0x09, 0x0d, 0xa1, 0xcd, 0x94, 0x2a, 0xa9, 0xf4,
	0x1a, 0x1e, 0x19, 0xe9, 0x52, 0x91, 0x25, 0xb5, 0x77, 0xe8, 0xa5, 0x0e, 0x18, 0x6f, 0xfa, 0xbc,
	0x60, 0xb2, 0xaa, 0xb3, 0x47, 0x58, 0xc0, 0x1d, 0x23, 0xcc, 0x16, 0x2c, 0x23, 0x9a, 0x3e, 0x2c,
	0xf9, 0x3c, 0xa7, 0xe8, 0x10, 0xfa, 0xd9, 0x9a, 0xf4, 0xfa, 0x75, 0x0a, 0xbd, 0x0e, 0xdb, 0x8c,
	0x6b, 0x2a, 0x57, 0x74, 0xce, 0x88, 0xb6, 0x05, 0x33, 0x3e, 0x4d, 0x12, 0x21, 0xd8, 0x94, 0x42,
	0x68, 0x1f, 0xd2, 0xda, 0xf8, 0x7b, 0x80, 0x73, 0x9b, 0xa8, 0xbd, 0xc4, 0xff, 0x18, 0x69, 0x5d,
	0xe3, 0xcd, 0x5a, 0x8d, 0xf1, 0x19, 0xec, 0xba, 0xf8, 0xca, 0xf5, 0x43, 0x15, 0x82, 0x2b, 0x8a,
	0x8e, 0xa1, 0xe3, 0xea, 0xa7, 0x92, 0xc0, 0xf6, 0x7e, 0x6f, 0xdd, 0xfb, 0x75, 0xbe, 0x69, 0xe5,
	0x84, 0xff, 0x0e, 0x20, 0x39, 0x95, 0x94, 0x68, 0x5a, 0x2b, 0x5f, 0xd5, 0xdd, 0x0f, 0x61, 0x20,
	0x9d, 0x39, 0x5d, 0x08, 0xb9, 0x22, 0xda, 0x5e, 0x6c, 0x70, 0x92, 0xac, 0x35, 0xcf, 0x78, 0x26,
	0xe6, 0x8c, 0x2f, 0x3f, 0xb1, 0xe7, 0xe9, 0xb6, 0xf7, 0x77, 0xd0, 0x0c, 0x82, 0x27, 0xaa, 0x41,
	0xf0, 0xb0, 0x3e, 0x22, 0x51, 0x63, 0x44, 0xd0, 0xab, 0xb0, 0xe5, 0x92, 0x9b, 0xd6, 0x6f, 0xdd,
	0x77, 0xdc, 0xe7, 0x76, 0xbe, 0xee, 0x41, 0xff, 0x19, 0xd3, 0x17, 0xd3, 0x99, 0x6d, 0xb3, 0x5d,
	0x93, 0x6e, 0x0a, 0x86, 0xf2, 0x8d, 0xdf, 0x83, 0x96, 0x16, 0x97, 0x94, 0x27, 0x6d, 0x57, 0x32,
	0x0b, 0xf0, 0x3f, 0x01, 0xec, 0xa4, 0x42, 0xe8, 0xda, 0x4d, 0xcd, 0xe6, 0xb0, 0xb9, 0xbd, 0x56,
	0x94, 0x86, 0x6c, 0x8e, 0xf6, 0xa1, 0x2b, 0x9e, 0x71, 0x2a, 0xa7, 0x6c, 0x6e, 0x53, 0x8e, 0xd2,
	0x8e, 0xc5, 0xe7, 0x73, 0xd3, 0x1b, 0x75, 0xc9, 0xe6, 0x55, 0x6f, 0x8c, 0x8d, 0xee, 0x42, 0x8f,
	0x0b, 0x3d, 0xa3, 0x0b, 0x21, 0xa9, 0xcd, 0x34, 0x4a, 0xd7, 0x84, 0x79, 0x16, 0xcc, 0x33, 0xb3,
	0xd0, 0x54, 0xda, 0x24, 0xa3, 0xf4, 0x05, 0xae, 0x8d, 0x7d, 0xbb, 0x31, 0xf6, 0x43, 0x68, 0xab,
	0x0b, 0x72, 0xf2, 0xe0, 0xbd, 0xa4, 0xe3, 0x78, 0x87, 0xd0, 0x1b, 0xd0, 0xb2, 0x45, 0x4f, 0xba,
	0xb6, 0x05, 0x3b, 0xeb, 0x16, 0x7c, 0x65, 0x8c, 0xd4, 0x9d, 0xa2, 0x18, 0xa2, 0x82, 0xae, 0x92,
	0x9e, 0xfd, 0xd6, 0x98, 0xf7, 0xdf, 0x82, 0x41, 0xb3, 0x49, 0xa8, 0x03, 0xd1, 0xe4, 0xec, 0x8b,
	0x78, 0xc3, 0x18, 0x1f, 0x9f, 0xa5, 0x71, 0x80, 0x7a, 0xd0, 0x9a, 0x7c, 0x76, 0xfa, 0xf8, 0xfd,
	0x38, 0xbc, 0xff, 0x26, 0xb4, 0xac, 0x20, 0x02, 0x68, 0x4f, 0xca, 0x59, 0xce, 0xb2, 0x78, 0x03,
	0xf5, 0xa1, 0x33, 0x91, 0xec, 0x29, 0xd1, 0x34, 0x0e, 0xcc, 0x57, 0x5f, 0xca, 0x65, 0x1c, 0x9e,
	0xfc, 0x12, 0x42, 0xef, 0xa3, 0x52, 0x5f, 0x08, 0x69, 0xde, 0xb9, 0x4b, 0xe8, 0xd7, 0xd7, 0xfa,
	0x70, 0x9d, 0xe0, 0x7f, 0xbf, 0x1d, 0xa3, 0xfd, 0x5b, 0x3d, 0xf0, 0xbd, 0x1f, 0x7e, 0xff, 0xeb,
	0xc7, 0x70, 0x1f, 0xbf, 0x34, 0x7e, 0xfa, 0xce, 0x38, 0x23, 0xe3, 0x4c, 0xc9, 0xb1, 0x9f, 0x8f,
	0x29, 0x33, 0xea, 0x66, 0xdd, 0x6f, 0x4e, 0x2d, 0xc2, 0x35, 0xc1, 0x5b, 0x46, 0x7a, 0xf4, 0x72,
	0x33, 0x68, 0xe3, 0xbd, 0xc0, 0xfb, 0x36, 0xec, 0x2e, 0xbe, 0x53, 0x0b, 0x9b, 0x59, 0x25, 0xf4,
	0x04, 0x3a, 0x7e, 0xdd, 0xd0, 0xb0, 0x36, 0xfd, 0xab, 0x42, 0x5f, 0x55, 0xd2, 0xaf, 0xdc, 0xdc,
	0xb4, 0xc6, 0x66, 0xe2, 0xa1, 0x15, 0x8f, 0xd1, 0xc0, 0x8b, 0xfb, 0x0d, 0x7c, 0x18, 0xff, 0x7a,
	0x7d, 0x10, 0xfc, 0x76, 0x7d, 0x10, 0xfc, 0x71, 0x7d, 0x10, 0xfc, 0xf4, 0xe7, 0xc1, 0xc6, 0xac,
	0x6d, 0xff, 0x48, 0xef, 0xfe, 0x1b, 0x00, 0x00, 0xff, 0xff, 0xf9, 0xb4, 0xba, 0x8c, 0xe8, 0x06,
	0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AuthorityClient is the client API for Authority service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AuthorityClient interface {
	// ProfileInfo returns the certificate profile info
	ProfileInfo(ctx context.Context, in *CertProfileInfoRequest, opts ...grpc.CallOption) (*CertProfileInfo, error)
	// CreateCertificate returns the certificate
	CreateCertificate(ctx context.Context, in *CreateCertificateRequest, opts ...grpc.CallOption) (*CertificateBundle, error)
	// Issuers returns the issuing CAs
	Issuers(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*IssuersInfoResponse, error)
}

type authorityClient struct {
	cc *grpc.ClientConn
}

func NewAuthorityClient(cc *grpc.ClientConn) AuthorityClient {
	return &authorityClient{cc}
}

func (c *authorityClient) ProfileInfo(ctx context.Context, in *CertProfileInfoRequest, opts ...grpc.CallOption) (*CertProfileInfo, error) {
	out := new(CertProfileInfo)
	err := c.cc.Invoke(ctx, "/trustypb.Authority/ProfileInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authorityClient) CreateCertificate(ctx context.Context, in *CreateCertificateRequest, opts ...grpc.CallOption) (*CertificateBundle, error) {
	out := new(CertificateBundle)
	err := c.cc.Invoke(ctx, "/trustypb.Authority/CreateCertificate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authorityClient) Issuers(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*IssuersInfoResponse, error) {
	out := new(IssuersInfoResponse)
	err := c.cc.Invoke(ctx, "/trustypb.Authority/Issuers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthorityServer is the server API for Authority service.
type AuthorityServer interface {
	// ProfileInfo returns the certificate profile info
	ProfileInfo(context.Context, *CertProfileInfoRequest) (*CertProfileInfo, error)
	// CreateCertificate returns the certificate
	CreateCertificate(context.Context, *CreateCertificateRequest) (*CertificateBundle, error)
	// Issuers returns the issuing CAs
	Issuers(context.Context, *EmptyRequest) (*IssuersInfoResponse, error)
}

// UnimplementedAuthorityServer can be embedded to have forward compatible implementations.
type UnimplementedAuthorityServer struct {
}

func (*UnimplementedAuthorityServer) ProfileInfo(ctx context.Context, req *CertProfileInfoRequest) (*CertProfileInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProfileInfo not implemented")
}
func (*UnimplementedAuthorityServer) CreateCertificate(ctx context.Context, req *CreateCertificateRequest) (*CertificateBundle, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCertificate not implemented")
}
func (*UnimplementedAuthorityServer) Issuers(ctx context.Context, req *EmptyRequest) (*IssuersInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Issuers not implemented")
}

func RegisterAuthorityServer(s *grpc.Server, srv AuthorityServer) {
	s.RegisterService(&_Authority_serviceDesc, srv)
}

func _Authority_ProfileInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CertProfileInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthorityServer).ProfileInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trustypb.Authority/ProfileInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthorityServer).ProfileInfo(ctx, req.(*CertProfileInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Authority_CreateCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCertificateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthorityServer).CreateCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trustypb.Authority/CreateCertificate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthorityServer).CreateCertificate(ctx, req.(*CreateCertificateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Authority_Issuers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthorityServer).Issuers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trustypb.Authority/Issuers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthorityServer).Issuers(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Authority_serviceDesc = grpc.ServiceDesc{
	ServiceName: "trustypb.Authority",
	HandlerType: (*AuthorityServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ProfileInfo",
			Handler:    _Authority_ProfileInfo_Handler,
		},
		{
			MethodName: "CreateCertificate",
			Handler:    _Authority_CreateCertificate_Handler,
		},
		{
			MethodName: "Issuers",
			Handler:    _Authority_Issuers_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkix.proto",
}

func (m *X509Name) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *X509Name) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *X509Name) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.OrganisationalUnit) > 0 {
		i -= len(m.OrganisationalUnit)
		copy(dAtA[i:], m.OrganisationalUnit)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.OrganisationalUnit)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Organisation) > 0 {
		i -= len(m.Organisation)
		copy(dAtA[i:], m.Organisation)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Organisation)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Locality) > 0 {
		i -= len(m.Locality)
		copy(dAtA[i:], m.Locality)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Locality)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Country) > 0 {
		i -= len(m.Country)
		copy(dAtA[i:], m.Country)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Country)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *X509Subject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *X509Subject) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *X509Subject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SerialNumber) > 0 {
		i -= len(m.SerialNumber)
		copy(dAtA[i:], m.SerialNumber)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.SerialNumber)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Names) > 0 {
		for iNdEx := len(m.Names) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Names[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPkix(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Cn) > 0 {
		i -= len(m.Cn)
		copy(dAtA[i:], m.Cn)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Cn)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CertProfileInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CertProfileInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CertProfileInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Profile) > 0 {
		i -= len(m.Profile)
		copy(dAtA[i:], m.Profile)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Profile)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Label) > 0 {
		i -= len(m.Label)
		copy(dAtA[i:], m.Label)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Label)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CertProfileInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CertProfileInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CertProfileInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Expiry) > 0 {
		i -= len(m.Expiry)
		copy(dAtA[i:], m.Expiry)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Expiry)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Usage) > 0 {
		for iNdEx := len(m.Usage) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Usage[iNdEx])
			copy(dAtA[i:], m.Usage[iNdEx])
			i = encodeVarintPkix(dAtA, i, uint64(len(m.Usage[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Issuer) > 0 {
		i -= len(m.Issuer)
		copy(dAtA[i:], m.Issuer)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Issuer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CertificateBundle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CertificateBundle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CertificateBundle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Root) > 0 {
		i -= len(m.Root)
		copy(dAtA[i:], m.Root)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Root)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Intermediates) > 0 {
		i -= len(m.Intermediates)
		copy(dAtA[i:], m.Intermediates)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Intermediates)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Certificate) > 0 {
		i -= len(m.Certificate)
		copy(dAtA[i:], m.Certificate)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Certificate)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IssuerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IssuerInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IssuerInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Label) > 0 {
		i -= len(m.Label)
		copy(dAtA[i:], m.Label)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Label)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Root) > 0 {
		i -= len(m.Root)
		copy(dAtA[i:], m.Root)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Root)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Intermediates) > 0 {
		i -= len(m.Intermediates)
		copy(dAtA[i:], m.Intermediates)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Intermediates)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Certificate) > 0 {
		i -= len(m.Certificate)
		copy(dAtA[i:], m.Certificate)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Certificate)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IssuersInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IssuersInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IssuersInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Issuers) > 0 {
		for iNdEx := len(m.Issuers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Issuers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPkix(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateCertificateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateCertificateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateCertificateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x32
	}
	if m.WithBundle {
		i--
		if m.WithBundle {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.IssuerLabel) > 0 {
		i -= len(m.IssuerLabel)
		copy(dAtA[i:], m.IssuerLabel)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.IssuerLabel)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Profile) > 0 {
		i -= len(m.Profile)
		copy(dAtA[i:], m.Profile)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Profile)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Request) > 0 {
		i -= len(m.Request)
		copy(dAtA[i:], m.Request)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Request)))
		i--
		dAtA[i] = 0x12
	}
	if m.RequestFormat != 0 {
		i = encodeVarintPkix(dAtA, i, uint64(m.RequestFormat))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RootCertificate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RootCertificate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RootCertificate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Pem) > 0 {
		i -= len(m.Pem)
		copy(dAtA[i:], m.Pem)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Pem)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Trust != 0 {
		i = encodeVarintPkix(dAtA, i, uint64(m.Trust))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Sha256) > 0 {
		i -= len(m.Sha256)
		copy(dAtA[i:], m.Sha256)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Sha256)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Issuer) > 0 {
		i -= len(m.Issuer)
		copy(dAtA[i:], m.Issuer)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Issuer)))
		i--
		dAtA[i] = 0x32
	}
	if m.Notafter != 0 {
		i = encodeVarintPkix(dAtA, i, uint64(m.Notafter))
		i--
		dAtA[i] = 0x28
	}
	if m.Notbefore != 0 {
		i = encodeVarintPkix(dAtA, i, uint64(m.Notbefore))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Skid) > 0 {
		i -= len(m.Skid)
		copy(dAtA[i:], m.Skid)
		i = encodeVarintPkix(dAtA, i, uint64(len(m.Skid)))
		i--
		dAtA[i] = 0x1a
	}
	if m.OwnerId != 0 {
		i = encodeVarintPkix(dAtA, i, uint64(m.OwnerId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintPkix(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintPkix(dAtA []byte, offset int, v uint64) int {
	offset -= sovPkix(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *X509Name) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Country)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	l = len(m.Locality)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	l = len(m.Organisation)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	l = len(m.OrganisationalUnit)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *X509Subject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Cn)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	if len(m.Names) > 0 {
		for _, e := range m.Names {
			l = e.Size()
			n += 1 + l + sovPkix(uint64(l))
		}
	}
	l = len(m.SerialNumber)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CertProfileInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	l = len(m.Profile)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CertProfileInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	if len(m.Usage) > 0 {
		for _, s := range m.Usage {
			l = len(s)
			n += 1 + l + sovPkix(uint64(l))
		}
	}
	l = len(m.Expiry)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CertificateBundle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Certificate)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	l = len(m.Intermediates)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	l = len(m.Root)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IssuerInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Certificate)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	l = len(m.Intermediates)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	l = len(m.Root)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IssuersInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Issuers) > 0 {
		for _, e := range m.Issuers {
			l = e.Size()
			n += 1 + l + sovPkix(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateCertificateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestFormat != 0 {
		n += 1 + sovPkix(uint64(m.RequestFormat))
	}
	l = len(m.Request)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	l = len(m.Profile)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	l = len(m.IssuerLabel)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	if m.WithBundle {
		n += 2
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RootCertificate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPkix(uint64(m.Id))
	}
	if m.OwnerId != 0 {
		n += 1 + sovPkix(uint64(m.OwnerId))
	}
	l = len(m.Skid)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	if m.Notbefore != 0 {
		n += 1 + sovPkix(uint64(m.Notbefore))
	}
	if m.Notafter != 0 {
		n += 1 + sovPkix(uint64(m.Notafter))
	}
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	l = len(m.Sha256)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	if m.Trust != 0 {
		n += 1 + sovPkix(uint64(m.Trust))
	}
	l = len(m.Pem)
	if l > 0 {
		n += 1 + l + sovPkix(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovPkix(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPkix(x uint64) (n int) {
	return sovPkix(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *X509Name) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPkix
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: X509Name: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: X509Name: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Country = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locality", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locality = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Organisation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Organisation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrganisationalUnit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrganisationalUnit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPkix(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPkix
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *X509Subject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPkix
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: X509Subject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: X509Subject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Names", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Names = append(m.Names, &X509Name{})
			if err := m.Names[len(m.Names)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SerialNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPkix(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPkix
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CertProfileInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPkix
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CertProfileInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CertProfileInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Profile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPkix(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPkix
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CertProfileInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPkix
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CertProfileInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CertProfileInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Usage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Usage = append(m.Usage, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiry", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expiry = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPkix(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPkix
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CertificateBundle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPkix
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CertificateBundle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CertificateBundle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Certificate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Certificate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intermediates", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Intermediates = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Root = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPkix(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPkix
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IssuerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPkix
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IssuerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IssuerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Certificate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Certificate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intermediates", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Intermediates = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Root = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPkix(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPkix
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IssuersInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPkix
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IssuersInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IssuersInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuers = append(m.Issuers, &IssuerInfo{})
			if err := m.Issuers[len(m.Issuers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPkix(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPkix
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateCertificateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPkix
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateCertificateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateCertificateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestFormat", wireType)
			}
			m.RequestFormat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestFormat |= EncodingFormat(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Profile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IssuerLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IssuerLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithBundle", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithBundle = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPkix(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPkix
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RootCertificate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPkix
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RootCertificate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RootCertificate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerId", wireType)
			}
			m.OwnerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Skid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notbefore", wireType)
			}
			m.Notbefore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Notbefore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notafter", wireType)
			}
			m.Notafter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Notafter |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sha256", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sha256 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trust", wireType)
			}
			m.Trust = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Trust |= Trust(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pem", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPkix
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPkix
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pem = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPkix(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPkix
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPkix(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPkix
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPkix
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPkix
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPkix
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPkix
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPkix        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPkix          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPkix = fmt.Errorf("proto: unexpected end of group")
)
